//////////////////////////////////////////////////////////////////////////////////////////
// File:            LuaMan.cpp
//////////////////////////////////////////////////////////////////////////////////////////
// Description:     Source file for the LuaMan class.
// Project:         Retro Terrain Engine
// Author(s):       Daniel Tabar
//                  data@datarealms.com
//                  http://www.datarealms.com


//////////////////////////////////////////////////////////////////////////////////////////
// Inclusions of header files

#include "LuaMan.h"
#include "System.h"
#include "RTEManagers.h"
#include "AllEntities.h"
#include "DataModule.h"
#include "ConsoleMan.h"
#include "SettingsMan.h"
#include "SLTerrain.h"
#include "GAScripted.h"
#include "Box.h"
#include "BuyMenuGUI.h"
#include "SceneEditorGUI.h"
#include "MetaPlayer.h"
#include "MetaMan.h"
#include "GUIBanner.h"
#include "TerrainObject.h"
#include "Emission.h"

extern "C"
{
  #include "lua.h"
  #include "lualib.h"
  #include "lauxlib.h"
}

// Allegro defines those via define in astdlib.h and Boost with stdlib go crazy about those so we need to undefine them manually.
#undef int8_t
#undef uint8_t
#undef int16_t
#undef uint16_t
#undef int32_t
#undef uint32_t
#undef intptr_t
#undef uintptr_t

#undef LONG_LONG
#undef int64_t
#undef uint64_t

#ifdef max
#undef max
#endif

// LuaBind
#include "luabind/luabind.hpp"
#include "luabind/operator.hpp"
#include "luabind/adopt_policy.hpp"
#include "luabind/detail/policy.hpp"
#include "luabind/out_value_policy.hpp"
#include "luabind/iterator_policy.hpp"
#include "luabind/return_reference_to_policy.hpp"


#define SOL_ALL_SAFETIES_ON 1
#include <sol/sol.hpp>

// Boost
//#include "boost/detail/shared_ptr_nmt.hpp"
//#include "boost/shared_ptr.hpp"

sol::state_view * g_pSolLuaState = 0;

template <typename... T>
using joined =
typename luabind::meta::join<T...>::type;


#include <string>
using namespace std;
using namespace luabind;

// From LuaBind documentation:
// If you want to add file name and line number to the error messages generated by luabind you can define your own pcall errorfunc.
// You may want to modify this callback to better suit your needs, but the basic functionality could be implemented like this:
// Filename and line number is already added by LuaBind.. and can't be associated when we're running things like GAScripted where the file is read in first and then the functions are executed afterward
/*int AddFileAndLineToError(lua_State* pState)
{
   lua_Debug luaDebug;
   lua_getstack(pState, 1, &luaDebug);
   lua_getinfo(pState, "Sln", &luaDebug);
   std::string errorString = lua_tostring(pState, -1);
   lua_pop(pState, 1);
   std::stringstream messageStream;
   messageStream << luaDebug.short_src << ":" << luaDebug.currentline;

   if (luaDebug.name != 0)
   {
      messageStream << "(" << luaDebug.namewhat << " " << luaDebug.name << ")";
   }
   messageStream << " " << errorString;
   lua_pushstring(pState, messageStream.str().c_str());

   return 1;
}*/


// From LuaBind documentation:
// You also have to supply two functions for your smart pointer.
// One that returns the type of const version of the smart pointer type (boost::shared_ptr<const A> in this case).
// And one function that extracts the raw pointer from the smart pointer.
// The first function is needed because luabind has to allow the non-const -> conversion when passing values from Lua to C++.
// The second function is needed when Lua calls member functions on held types, the this pointer must be a raw pointer, it is also needed to allow the smart_pointer -> raw_pointer conversion from Lua to C++.

namespace luabind
{
    template<class T>
    T * get_pointer(std::shared_ptr<T> &p)
    {
        return p.get();
    }

// From LuaBind documentation:
// IMPORTANT
// get_const_holder() has been removed.
// Automatic conversions between smart_ptr<X> and smart_ptr<X const> no longer work.
    /*template<class A>
    boost::shared_ptr<const A> * get_const_holder(boost::shared_ptr<A> *)
    {
        return 0;
    }*/
}


namespace RTE
{

const string LuaMan::m_ClassName = "LuaMan";

int use_sol2(lua_State* L)
{
	g_LuaMan.CreateSolState(L);
	return 0;
}

void LuaMan::CreateSolState(lua_State * L)
{
	g_pSolLuaState = new sol::state_view(L);
	g_pSolLuaState->script("print('Sol2 Initialized')");
}


//////////////////////////////////////////////////////////////////////////////////////////
// Preset clone adapters that will return the exact pre-cast types so we don't have to do:
// myNewActor = ToActor(PresetMan:GetPreset("AHuman", "Soldier Light", "All")):Clone()
// but can instead do:
// myNewActor = CreateActor("Soldier Light", "All");
// or even:
// myNewActor = CreateActor("Soldier Light");
// or for a randomly selected Preset within a group:
// myNewActor = RandomActor("Light Troops");

#define LUAENTITYCREATE(TYPE) \
    TYPE * Create##TYPE(std::string preset, std::string module) \
    { \
        const Entity *pPreset = g_PresetMan.GetEntityPreset(#TYPE, preset, module); \
        if (!pPreset) \
        { \
            g_ConsoleMan.PrintString(string("ERROR: There is no ") + string(#TYPE) + string(" of the Preset name \"") + preset + string("\" defined in the \"") + module + string("\" Data Module!")); \
            return 0; \
        } \
        return dynamic_cast<TYPE *>(pPreset->Clone()); \
    } \
    TYPE * Create##TYPE(std::string preset) { return Create##TYPE(preset, "All"); } \
    TYPE * Random##TYPE(std::string group, int moduleSpaceID) \
    { \
        const Entity *pPreset = g_PresetMan.GetRandomBuyableOfGroupFromTech(group, #TYPE, moduleSpaceID); \
        if (!pPreset) \
            pPreset = g_PresetMan.GetRandomBuyableOfGroupFromTech(group, #TYPE, g_PresetMan.GetModuleID("Base.rte")); \
        if (!pPreset) \
            pPreset = g_PresetMan.GetRandomBuyableOfGroupFromTech("Any", #TYPE, moduleSpaceID); \
        if (!pPreset) \
        { \
            g_ConsoleMan.PrintString(string("ERROR: Could not find any ") + string(#TYPE) + string(" defined in a Group called \"") + group + string("\" in module ") + g_PresetMan.GetDataModuleName(moduleSpaceID) + string("!")); \
            return 0; \
        } \
        return dynamic_cast<TYPE *>(pPreset->Clone()); \
    } \
    TYPE * Random##TYPE(std::string group, std::string module) \
    { \
        int moduleSpaceID = g_PresetMan.GetModuleID(module); \
        const Entity *pPreset = g_PresetMan.GetRandomBuyableOfGroupFromTech(group, #TYPE, moduleSpaceID); \
        if (!pPreset) \
            pPreset = g_PresetMan.GetRandomBuyableOfGroupFromTech(group, #TYPE, g_PresetMan.GetModuleID("Base.rte")); \
        if (!pPreset) \
            pPreset = g_PresetMan.GetRandomBuyableOfGroupFromTech("Any", #TYPE, moduleSpaceID); \
        if (!pPreset) \
        { \
            g_ConsoleMan.PrintString(string("ERROR: Could not find any ") + string(#TYPE) + string(" defined in a Group called \"") + group + string("\" in module ") + module + string("!")); \
            return 0; \
        } \
        return dynamic_cast<TYPE *>(pPreset->Clone()); \
    } \
    TYPE * Random##TYPE(std::string group) { return Random##TYPE(group, "All"); }

// These are expanded by the preprocessor to all the different cloning function definitions.
LUAENTITYCREATE(Attachable)
LUAENTITYCREATE(AEmitter)
LUAENTITYCREATE(Turret)
LUAENTITYCREATE(Actor)
LUAENTITYCREATE(ADoor)
LUAENTITYCREATE(AHuman)
LUAENTITYCREATE(ACrab)
LUAENTITYCREATE(ACraft)
LUAENTITYCREATE(ACDropShip)
LUAENTITYCREATE(ACRocket)
LUAENTITYCREATE(MOSParticle)
LUAENTITYCREATE(MOSRotating)
LUAENTITYCREATE(MOPixel)
LUAENTITYCREATE(Scene)
LUAENTITYCREATE(HeldDevice)
LUAENTITYCREATE(Round)
LUAENTITYCREATE(Magazine)
LUAENTITYCREATE(HDFirearm)
LUAENTITYCREATE(ThrownDevice)
LUAENTITYCREATE(TDExplosive)
LUAENTITYCREATE(TerrainObject)


//////////////////////////////////////////////////////////////////////////////////////////
// Clone adapters that will return the exact pre-cast types so we don't have to do:
// myOtherActor = ToActor(myActor:Clone());
// but can instead do:
// myOtherActor = myActor:Clone();

// Preprocessor helper function so we don't need to maintain a dozen almost identical definitions
#define LUAENTITYCLONE(TYPE) \
    TYPE * Clone##TYPE(const TYPE *pThis) \
        { \
            if (pThis) \
                return dynamic_cast<TYPE *>(pThis->Clone()); \
            else \
                g_ConsoleMan.PrintString(string("ERROR: Tried to clone a ") + string(#TYPE) + string(" reference that is nil!")); \
            return 0; \
        }

// These are expanded by the preprocessor to all the different cloning function definitions.
LUAENTITYCLONE(Entity)
LUAENTITYCLONE(SceneObject)
LUAENTITYCLONE(MovableObject)
LUAENTITYCLONE(Attachable)
LUAENTITYCLONE(AEmitter)
LUAENTITYCLONE(Turret)
LUAENTITYCLONE(Actor)
LUAENTITYCLONE(ADoor)
LUAENTITYCLONE(AHuman)
LUAENTITYCLONE(ACrab)
LUAENTITYCLONE(ACraft)
LUAENTITYCLONE(ACDropShip)
LUAENTITYCLONE(ACRocket)
LUAENTITYCLONE(MOSParticle)
LUAENTITYCLONE(MOSRotating)
LUAENTITYCLONE(MOPixel)
LUAENTITYCLONE(Scene)
LUAENTITYCLONE(HeldDevice)
LUAENTITYCLONE(Round)
LUAENTITYCLONE(Magazine)
LUAENTITYCLONE(HDFirearm)
LUAENTITYCLONE(ThrownDevice)
LUAENTITYCLONE(TDExplosive)
LUAENTITYCLONE(TerrainObject)

//////////////////////////////////////////////////////////////////////////////////////////
// Explicit deletion of any Entity instance that Lua owns.. it will probably be handled
// by the GC, but this makes it instantaneous

void DeleteEntity(Entity *pEntity)
{
    delete pEntity;
    pEntity = 0;
}


//////////////////////////////////////////////////////////////////////////////////////////
// "Downcast" conversion functions from Entity to common derived types

// Preprocessor helper function so we don't need to maintain a dozen almost identical definitions
#define LUAENTITYCAST(TYPE) \
    TYPE * To##TYPE(Entity *pEntity) \
    { \
        TYPE *pTarget = dynamic_cast<TYPE *>(pEntity); \
        if (!pTarget) \
            g_ConsoleMan.PrintString(string("ERROR: Tried to convert a non-") + string(#TYPE) + string(" Entity reference to an ") + string(#TYPE) + string(" reference!")); \
        return pTarget; \
    } \
    const TYPE * ToConst##TYPE(const Entity *pEntity) \
    { \
        const TYPE *pTarget = dynamic_cast<const TYPE *>(pEntity); \
        if (!pTarget) \
            g_ConsoleMan.PrintString(string("ERROR: Tried to convert a non-") + string(#TYPE) + string(" Entity reference to an ") + string(#TYPE) + string(" reference!")); \
        return pTarget; \
    } \
    bool Is##TYPE(Entity *pEntity) { return dynamic_cast<TYPE *>(pEntity) ? true : false; }

// These are expanded by the preprocessor to all the different casting function definitions named: To[Type]()
LUAENTITYCAST(SceneObject)
LUAENTITYCAST(MovableObject)
LUAENTITYCAST(Entity)
LUAENTITYCAST(Attachable)
LUAENTITYCAST(Arm)
LUAENTITYCAST(Emission)
LUAENTITYCAST(AEmitter)
LUAENTITYCAST(Turret)
LUAENTITYCAST(Actor)
LUAENTITYCAST(ADoor)
LUAENTITYCAST(AHuman)
LUAENTITYCAST(ACrab)
LUAENTITYCAST(ACraft)
LUAENTITYCAST(ACDropShip)
LUAENTITYCAST(ACRocket)
LUAENTITYCAST(MOSParticle)
LUAENTITYCAST(MOSRotating)
LUAENTITYCAST(MOPixel)
LUAENTITYCAST(MOSprite)
LUAENTITYCAST(Scene)
LUAENTITYCAST(Deployment)
LUAENTITYCAST(GameActivity)
LUAENTITYCAST(GlobalScript)
LUAENTITYCAST(GAScripted)
LUAENTITYCAST(HeldDevice)
LUAENTITYCAST(Round)
LUAENTITYCAST(Magazine)
LUAENTITYCAST(HDFirearm)
LUAENTITYCAST(ThrownDevice)
LUAENTITYCAST(TDExplosive)
LUAENTITYCAST(TerrainObject)


//////////////////////////////////////////////////////////////////////////////////////////
// Common LuaBind bindings for abstract and concrete Entities

#define ABSTRACTLUABINDING(TYPE, PARENT) \
    def((string("To") + string(#TYPE)).c_str(), (TYPE *(*)(Entity *))&To##TYPE), \
    def((string("To") + string(#TYPE)).c_str(), (const TYPE *(*)(const Entity *))&ToConst##TYPE), \
    class_<TYPE, PARENT/*, boost::shared_ptr<Entity> */>(#TYPE) \
        .property("ClassName", &TYPE::GetClassName)

#define ABSTRACTLUABINDING_SOL(TYPE, PARENT) \
    g_pSolLuaState->set((string("To") + string(#TYPE)).c_str(), To##TYPE); \
	g_pSolLuaState->set((string("To") + string(#TYPE)).c_str(), ToConst##TYPE); \
	sol::usertype<TYPE> Bind = g_pSolLuaState->new_usertype<TYPE>(#TYPE, sol::no_constructor); \
	Bind["ClassName"] = &TYPE::GetClassName;

#define CONCRETELUABINDING(TYPE, PARENT) \
    def((string("Create") + string(#TYPE)).c_str(), (TYPE *(*)(string, string))&Create##TYPE, luabind::adopt_policy<0>()), \
    def((string("Create") + string(#TYPE)).c_str(), (TYPE *(*)(string))&Create##TYPE, luabind::adopt_policy<0>()), \
    def((string("Random") + string(#TYPE)).c_str(), (TYPE *(*)(string, int))&Random##TYPE, luabind::adopt_policy<0>()), \
    def((string("Random") + string(#TYPE)).c_str(), (TYPE *(*)(string, string))&Random##TYPE, luabind::adopt_policy<0>()), \
    def((string("Random") + string(#TYPE)).c_str(), (TYPE *(*)(string))&Random##TYPE, luabind::adopt_policy<0>()), \
    def((string("To") + string(#TYPE)).c_str(), (TYPE *(*)(Entity *))&To##TYPE), \
    def((string("To") + string(#TYPE)).c_str(), (const TYPE *(*)(const Entity *))&ToConst##TYPE), \
    def((string("Is") + string(#TYPE)).c_str(), (bool(*)(const Entity *))&Is##TYPE), \
    class_<TYPE, PARENT/*, boost::shared_ptr<Entity> */>(#TYPE) \
        .def("Clone", &Clone##TYPE, luabind::adopt_policy<0>()) \
        .property("ClassName", &TYPE::GetClassName)

#define CONCRETELUABINDING_SOL(TYPE, PARENT) \
	g_pSolLuaState->set((string("Create") + string(#TYPE)).c_str(), (TYPE *(*)(string, string))Create##TYPE); \
	g_pSolLuaState->set((string("Create") + string(#TYPE)).c_str(), (TYPE *(*)(string))Create##TYPE); \
	g_pSolLuaState->set((string("Random") + string(#TYPE)).c_str(), (TYPE *(*)(string, int))Random##TYPE); \
	g_pSolLuaState->set((string("Random") + string(#TYPE)).c_str(), (TYPE *(*)(string, string))Random##TYPE); \
	g_pSolLuaState->set((string("Random") + string(#TYPE)).c_str(), (TYPE *(*)(string))Random##TYPE); \
	g_pSolLuaState->set((string("To") + string(#TYPE)).c_str(), To##TYPE); \
	g_pSolLuaState->set((string("To") + string(#TYPE)).c_str(), ToConst##TYPE); \
	g_pSolLuaState->set((string("Is") + string(#TYPE)).c_str(), Is##TYPE); \
	sol::usertype<TYPE> Bind = g_pSolLuaState->new_usertype<TYPE>(#TYPE, sol::no_constructor); \
	Bind["ClassName"] = &TYPE::GetClassName;


//////////////////////////////////////////////////////////////////////////////////////////
// Other misc adapters to eliminate/emulate default parameters etc

/*void GibThis(MOSRotating *pThis) { pThis->GibThis(); }
void AddMO(MovableMan &This, MovableObject *pMO)
{
    if (This.ValidMO(pMO))
        g_ConsoleMan.PrintString("ERROR: Tried to add a MovableObject that already exists in the simulation! " + pMO->GetPresetName());
    else
        This.AddMO(pMO);
}
void AddActor(MovableMan &This, Actor *pActor)
{
    if (This.IsActor(pActor))
        g_ConsoleMan.PrintString("ERROR: Tried to add an Actor that already exists in the simulation!" + pActor->GetPresetName());
    else
        This.AddActor(pActor);
}
void AddItem(MovableMan &This, MovableObject *pItem)
{
    if (This.ValidMO(pItem))
        g_ConsoleMan.PrintString("ERROR: Tried to add an Item that already exists in the simulation!" + pItem->GetPresetName());
    else
        This.AddItem(pItem);
}
void AddParticle(MovableMan &This, MovableObject *pParticle)
{
    if (This.ValidMO(pParticle))
        g_ConsoleMan.PrintString("ERROR: Tried to add a Particle that already exists in the simulation!" + pParticle->GetPresetName());
    else
        This.AddParticle(pParticle);
}*/

/*
//////////////////////////////////////////////////////////////////////////////////////////
// Wrapper for the GAScripted so we can derive new classes from it purely in lua:
//
// "It is also possible to derive Lua classes from C++ classes, and override virtual functions with Lua functions.
// To do this we have to create a wrapper class for our C++ base class.
// This is the class that will hold the Lua object when we instantiate a Lua class"

struct GAScriptedWrapper:
    GAScripted,
    wrap_base
{
    GAScriptedWrapper(): GAScripted() { ; }

    // Passing in the path of the script file that defines, in Lua, the GAScripted-derived class
//    virtual int Create(const GAScripted &reference) { return call<int>("Create", reference); }
    virtual Entity * Clone(Entity *pCloneTo = 0) const { return call<Entity *>("Clone", pCloneTo); }
    virtual int Start() { call<int>("Start"); }
    virtual void Pause(bool pause) { call<void>("Pause", pause); }
    virtual void End() { call<void>("End"); }
    virtual void Update() { call<void>("Update"); }

//    static int static_Create(GAScripted *pSelf, const GAScripted &reference) { return pSelf->GAScripted::Create(reference); }
    static Entity * static_Clone(GAScripted *pSelf, Entity *pCloneTo = 0) { return pSelf->GAScripted::Clone(pCloneTo); }
    static int static_Start(GAScripted *pSelf) { return pSelf->GAScripted::Start(); }
    static void static_Pause(GAScripted *pSelf, bool pause) { return pSelf->GAScripted::Pause(pause); }
    static void static_End(GAScripted *pSelf) { return pSelf->GAScripted::End(); }
    static void static_Update(GAScripted *pSelf) { return pSelf->GAScripted::Update(); }
};
*/

//////////////////////////////////////////////////////////////////////////////////////////
// Method:          Clear
//////////////////////////////////////////////////////////////////////////////////////////
// Description:     Clears all the member variables of this LuaMan, effectively
//                  resetting the members of this abstraction level only.

void LuaMan::Clear()
{
    m_pMasterState = 0;
    m_LastError.clear();
// TODO: is this the best way to give ID's.. won't ever be reset?
    m_NextPresetID = 0;
    m_NextObjectID = 0;
    m_pTempEntity = 0;

	//Clear files list
	for (int i = 0; i < MAX_OPEN_FILES; ++i)
		m_Files[i] = 0;
}

//////////////////////////////////////////////////////////////////////////////////////////
// Method:          Create
//////////////////////////////////////////////////////////////////////////////////////////
// Description:     Makes the LuaMan object ready for use.

int LuaMan::Create()
{
    // Create the master state
    m_pMasterState = lua_open();
    // Attach the master state to LuaBind
    open(m_pMasterState);
    // Open the lua libs for the master state
    //luaL_openlibs(m_pMasterState);

	// Load only libraries we need
	lua_pushcfunction(m_pMasterState, luaopen_base);
	lua_pushliteral(m_pMasterState, LUA_COLIBNAME);
	lua_call(m_pMasterState, 1, 0);

	lua_pushcfunction(m_pMasterState, luaopen_table);
	lua_pushliteral(m_pMasterState, LUA_TABLIBNAME);
	lua_call(m_pMasterState, 1, 0);

	lua_pushcfunction(m_pMasterState, luaopen_string);
	lua_pushliteral(m_pMasterState, LUA_STRLIBNAME);
	lua_call(m_pMasterState, 1, 0);

	lua_pushcfunction(m_pMasterState, luaopen_math);
	lua_pushliteral(m_pMasterState, LUA_MATHLIBNAME);
	lua_call(m_pMasterState, 1, 0);

	lua_pushcfunction(m_pMasterState, luaopen_debug);
	lua_pushliteral(m_pMasterState, LUA_DBLIBNAME);
	lua_call(m_pMasterState, 1, 0);

	lua_pushcfunction(m_pMasterState, luaopen_package);
	lua_pushliteral(m_pMasterState, LUA_LOADLIBNAME);
	lua_call(m_pMasterState, 1, 0);


	lua_pushcclosure(m_pMasterState, &use_sol2, 0);
	lua_setglobal(m_pMasterState, "use_sol2");

	if (luaL_dostring(m_pMasterState, "use_sol2()")) {
		lua_error(m_pMasterState);
		return -1;
	}


    // From LuaBind documentation:
    // As mentioned in the Lua documentation, it is possible to pass an error handler function to lua_pcall().
    // Luabind makes use of lua_pcall() internally when calling member functions and free functions.
    // It is possible to set the error handler function that Luabind will use globally:
    //set_pcall_callback(&AddFileAndLineToError);

	///////////////////////////////////////////////////////////////////////////
	// Vector
	///////////////////////////////////////////////////////////////////////////
	{
		/*class_<Vector>("Vector")
				   .def(luabind::constructor<>())
				   .def(luabind::constructor<float, float>())
				   .def(self == other<const Vector &>())
				   .def(const_self + other<const Vector &>())
				   .def(const_self - other<const Vector &>())
				   .def(const_self * float())
				   .def(const_self / float())
				   .def(tostring(const_self))
				   .property("ClassName", &Vector::GetClassName)
				   .property("RoundedX", &Vector::GetRoundIntX)
				   .property("RoundedY", &Vector::GetRoundIntY)
				   .property("Rounded", &Vector::GetRounded)
				   .property("FlooredX", &Vector::GetFloorIntX)
				   .property("FlooredY", &Vector::GetFloorIntY)
				   .property("Floored", &Vector::GetFloored)
				   .property("CeilingedX", &Vector::GetCeilingIntX)
				   .property("CeilingedY", &Vector::GetCeilingIntY)
				   .property("Ceilinged", &Vector::GetCeilinged)
				   .property("Magnitude", &Vector::GetMagnitude)
				   .def("SetMagnitude", &Vector::SetMagnitude)
				   .property("Largest", &Vector::GetLargest)
				   .property("Smallest", &Vector::GetSmallest)
				   .property("Normalized", &Vector::GetNormalized)
				   .property("Perpendicular", &Vector::GetPerpendicular)
				   .def("GetXFlipped", &Vector::GetXFlipped)
				   .def("GetYFlipped", &Vector::GetYFlipped)
				   .property("AbsRadAngle", &Vector::GetAbsRadAngle)
				   .property("AbsDegAngle", &Vector::GetAbsDegAngle)
				   .def("CapMagnitude", &Vector::CapMagnitude)
				   .def("FlipX", &Vector::FlipX)
				   .def("FlipY", &Vector::FlipY)
				   .def("IsZero", &Vector::IsZero)
				   .def("IsOpposedTo", &Vector::IsOpposedTo)
				   .def("Dot", &Vector::Dot)
				   .def("Cross", &Vector::Cross)
				   .def("Round", &Vector::Round)
				   .def("ToHalf", &Vector::ToHalf)
				   .def("Floor", &Vector::Floor)
				   .def("Ceiling", &Vector::Ceiling)
				   .def("Normalize", &Vector::Normalize)
				   .def("Perpendicularize", &Vector::Perpendicularize)
				   .def("Reset", &Vector::Reset)
				   .def("RadRotate", &Vector::RadRotate)
				   .def("DegRotate", &Vector::DegRotate)
				   .def("AbsRotateTo", &Vector::AbsRotateTo)
				   .def_readwrite("X", &Vector::m_X)
				   .def_readwrite("Y", &Vector::m_Y)
				   .def("SetXY", &Vector::SetXY),//*/



		sol::usertype<Vector> Bind = g_pSolLuaState->new_usertype<Vector>("Vector",
			sol::constructors<Vector(), Vector(float, float)>(),
			sol::call_constructor, sol::constructors<Vector(), Vector(Vector &), Vector(float, float)>()
		);

		Bind[sol::meta_function::equal_to] = sol::resolve<bool(const Vector&, const Vector&)>(RTE::operator==);
		Bind[sol::meta_function::unary_minus] = sol::resolve<Vector()>(&Vector::operator-);
		Bind[sol::meta_function::addition] = sol::resolve<Vector(const Vector &, const Vector &)>(&RTE::operator -);
		Bind[sol::meta_function::addition] = sol::resolve<Vector(const Vector &, const Vector &)>(&RTE::operator +);
		Bind[sol::meta_function::multiplication] = &Vector::operator *;
		Bind[sol::meta_function::division] = &Vector::operator /;

		Bind["ClassName"] = sol::property(&Vector::GetClassName);
		Bind["RoundedX"] = sol::property(&Vector::GetRoundIntX);
		Bind["RoundedY"] = sol::property(&Vector::GetRoundIntY);
		Bind["Rounded"] = sol::property(&Vector::GetRounded);
		Bind["FlooredX"] = sol::property(&Vector::GetFloorIntX);
		Bind["FlooredY"] = sol::property(&Vector::GetFloorIntY);
		Bind["Floored"] = sol::property(&Vector::GetFloored);
		Bind["CeilingedX"] = sol::property(&Vector::GetCeilingIntX);
		Bind["CeilingedY"] = sol::property(&Vector::GetCeilingIntY);
		Bind["Ceilinged"] = sol::property(&Vector::GetCeilinged);
		Bind["Magnitude"] = sol::property(&Vector::GetMagnitude);
		Bind["SetMagnitude"] = &Vector::SetMagnitude;
		Bind["Largest"] = sol::property(&Vector::GetLargest);
		Bind["Smallest"] = sol::property(&Vector::GetSmallest);
		Bind["Normalized"] = sol::property(&Vector::GetNormalized);
		Bind["Perpendicular"] = sol::property(&Vector::GetPerpendicular);
		Bind["GetXFlipped"] = &Vector::GetXFlipped;
		Bind["GetYFlipped"] = &Vector::GetYFlipped;
		Bind["AbsRadAngle"] = sol::property(&Vector::GetAbsRadAngle);
		Bind["AbsDegAngle"] = sol::property(&Vector::GetAbsDegAngle);
		Bind["CapMagnitude"] = &Vector::CapMagnitude;
		Bind["FlipX"] = &Vector::FlipX;
		Bind["FlipY"] = &Vector::FlipY;
		Bind["IsZero"] = &Vector::IsZero;
		Bind["IsOpposedTo"] = &Vector::IsOpposedTo;
		Bind["Dot"] = &Vector::Dot;
		Bind["Cross"] = &Vector::Cross;
		Bind["Round"] = &Vector::Round;
		Bind["ToHalf"] = &Vector::ToHalf;
		Bind["Floor"] = &Vector::Floor;
		Bind["Ceiling"] = &Vector::Ceiling;
		Bind["Normalize"] = &Vector::Normalize;
		Bind["Perpendicularize"] = &Vector::Perpendicularize;
		Bind["Reset"] = &Vector::Reset;
		Bind["RadRotate"] = &Vector::RadRotate;
		Bind["DegRotate"] = &Vector::DegRotate;
		Bind["AbsRotateTo"] = &Vector::AbsRotateTo;
		// For whatever reasons binding simply as variable breaks the VS 2017 compiler
		Bind["X"] = sol::property(&Vector::GetX, &Vector::SetX);
		Bind["Y"] = sol::property(&Vector::GetY, &Vector::SetY);
		Bind["SetXY"] = &Vector::SetXY;//*/
	}

	///////////////////////////////////////////////////////////////////////////
	// Box
	///////////////////////////////////////////////////////////////////////////

		/*class_<Box>("Box")
			.def(constructor<>())
			.def(constructor<const Vector &, const Vector &>())
			.def(constructor<float, float, float, float>())
			.def(constructor<const Vector &, float, float>())
			.def(constructor<const Box &>())
			.def(self == other<const Box &>())
			.property("ClassName", &Box::GetClassName)
			.property("Corner", &Box::GetCorner, &Box::SetCorner)
			.property("Width", &Box::GetWidth, &Box::SetWidth)
			.property("Height", &Box::GetHeight, &Box::SetHeight)
			.property("Center", &Box::GetCenter, &Box::SetCenter)
			.property("Area", &Box::GetArea)
			.def("GetRandomPoint", &Box::GetRandomPoint)
			.def("Unflip", &Box::Unflip)
			.def("WithinBox", &Box::WithinBox)
			.def("WithinBoxX", &Box::WithinBoxX)
			.def("WithinBoxY", &Box::WithinBoxY)
			.def("GetWithinBoxX", &Box::GetWithinBoxX)
			.def("GetWithinBoxY", &Box::GetWithinBoxY)
			.def("GetWithinBox", &Box::GetWithinBox), */


	{
		sol::usertype<Box> Bind = g_pSolLuaState->new_usertype<Box>("Box",
			sol::constructors<Box(), Box(const Vector &, const Vector &), Box(float, float, float, float), Box(const Vector &, float, float), Box(const Box &)>(),
			sol::call_constructor, sol::constructors<Box(), Box(const Vector &, const Vector &), Box(float, float, float, float), Box(const Vector &, float, float), Box(const Box &)>()
			);

		Bind[sol::meta_function::equal_to] = sol::resolve<bool(const Box&, const Box&)>(RTE::operator==);

		Bind["ClassName"] = &Box::GetClassName;
		Bind["Corner"] = sol::property(&Box::GetCorner, &Box::SetCorner);
		Bind["Width"] = sol::property(&Box::GetWidth, &Box::SetWidth);
		Bind["Height"] = sol::property(&Box::GetHeight, &Box::SetHeight);
		Bind["Center"] = sol::property(&Box::GetCenter, &Box::SetCenter);
		Bind["Area"] = sol::property(&Box::GetArea);
		Bind["GetRandomPoint"] = &Box::GetRandomPoint;
		Bind["Unflip"] = &Box::Unflip;
		Bind["WithinBox"] = &Box::WithinBox;
		Bind["WithinBoxX"] = &Box::WithinBoxX;
		Bind["WithinBoxY"] = &Box::WithinBoxY;
		Bind["GetWithinBoxX"] = &Box::GetWithinBoxX;
		Bind["GetWithinBoxY"] = &Box::GetWithinBoxY;
		Bind["GetWithinBox"] = &Box::GetWithinBox;//*/
	}


	///////////////////////////////////////////////////////////////////////////
	// Area
	///////////////////////////////////////////////////////////////////////////
	{
		/*class_<Scene::Area>("Area")
			.def(constructor<>())
			.def(constructor<string>())
			.def(constructor<const Scene::Area &>())
			.def("Reset", &Scene::Area::Reset)
			.property("ClassName", &Scene::Area::GetClassName)
			.property("Name", &Scene::Area::GetName)
			.def("AddBox", &Scene::Area::AddBox)
			.def("HasNoArea", &Scene::Area::HasNoArea)
			.def("IsInside", &Scene::Area::IsInside)
			.def("GetBoxInside", &Scene::Area::GetBoxInside)
			.def("RemoveBoxInside", &Scene::Area::RemoveBoxInside)
			.def("GetCenterPoint", &Scene::Area::GetCenterPoint)
			.def("GetRandomPoint", &Scene::Area::GetRandomPoint), */

		sol::usertype<Scene::Area> Bind = g_pSolLuaState->new_usertype<Scene::Area>("Area",
			sol::constructors<Scene::Area(), Scene::Area(string), Scene::Area(const Scene::Area &)>(),
			sol::call_constructor, sol::constructors<Scene::Area(), Scene::Area(string), Scene::Area(const Scene::Area &)>()
		);

		Bind["Reset"] = &Scene::Area::Reset;
		Bind["ClassName"] = sol::property(&Scene::Area::GetClassName);
		Bind["Name"] = sol::property(&Scene::Area::GetName);
		Bind["AddBox"] = &Scene::Area::AddBox;
		Bind["HasNoArea"] = &Scene::Area::HasNoArea;
		Bind["IsInside"] = &Scene::Area::IsInside;
		Bind["GetBoxInside"] = &Scene::Area::GetBoxInside;
		Bind["RemoveBoxInside"] = &Scene::Area::RemoveBoxInside;
		Bind["GetCenterPoint"] = &Scene::Area::GetCenterPoint;
		Bind["GetRandomPoint"] = &Scene::Area::GetRandomPoint;//*/
	}


	///////////////////////////////////////////////////////////////////////////
	// Entity
	///////////////////////////////////////////////////////////////////////////
	{
		/*class_<Entity>("Entity")
			.def("Clone", &CloneEntity)
			.def("Reset", &Entity::Reset)
			.def(tostring(const_self))
			.property("ClassName", &Entity::GetClassName)
			.property("PresetName", &Entity::GetPresetName, &Entity::SetPresetName)
			.def("GetModuleAndPresetName", &Entity::GetModuleAndPresetName)
			.property("IsOriginalPreset", &Entity::IsOriginalPreset)
			.property("ModuleID", &Entity::GetModuleID)
			.property("RandomWeight", &Entity::GetRandomWeight)
			.def("AddToGroup", &Entity::AddToGroup)
			.def("IsInGroup", (bool (Entity::*)(const string &))&Entity::IsInGroup),*/

		sol::usertype<Entity> Bind = g_pSolLuaState->new_usertype<Entity>("Entity", sol::no_constructor);

		Bind["Clone"] = &CloneEntity;
		Bind["Reset"] = &Entity::Reset;
		Bind["ClassName"] = sol::property(&Entity::GetClassName);
		Bind["PresetName"] = sol::property(&Entity::GetPresetName, &Entity::SetPresetName);
		Bind["GetModuleAndPresetName"] = &Entity::GetModuleAndPresetName;
		Bind["IsOriginalPreset"] = sol::property(&Entity::IsOriginalPreset);
		Bind["ModuleID"] = sol::property(&Entity::GetModuleID);
		Bind["RandomWeight"] = sol::property(&Entity::GetRandomWeight);
		Bind["AddToGroup"] = &Entity::AddToGroup;
		Bind["IsInGroup"] = &Entity::IsInGroup;//*/
	}


	///////////////////////////////////////////////////////////////////////////
	// Sound
	///////////////////////////////////////////////////////////////////////////
	{
		/*class_<Sound>("Sound")
			.def(constructor<>())
			.def("IsPlaying", &Sound::IsBeingPlayed)
			.def("Stop", &Sound::Stop)
			.def("UpdateDistance", &Sound::UpdateAttenuation),
			//.property("Loops", &Sound::GetLoopSetting, &Sound::SetLoopSetting),*/


		sol::usertype<Sound> Bind = g_pSolLuaState->new_usertype<Sound>("Sound", sol::no_constructor);

		Bind["IsPlaying"] = &Sound::IsBeingPlayed;
		Bind["Stop"] = &Sound::Stop;
		Bind["UpdateDistance"] = &Sound::UpdateAttenuation;//*/
	}

	///////////////////////////////////////////////////////////////////////////
	// SceneOnject
	///////////////////////////////////////////////////////////////////////////
	{
		/*ABSTRACTLUABINDING(SceneObject, Entity)
			.property("Pos", &SceneObject::GetPos, &SceneObject::SetPos)
			.property("HFlipped", &SceneObject::IsHFlipped, &SceneObject::SetHFlipped)
			.property("RotAngle", &SceneObject::GetRotAngle, &SceneObject::SetRotAngle)
			.property("Team", &SceneObject::GetTeam, &SceneObject::SetTeam)
			.property("PlacedByPlayer", &SceneObject::GetPlacedByPlayer, &SceneObject::SetPlacedByPlayer)
			.def("GetGoldValue", &SceneObject::GetGoldValueOld)
			.def("GetGoldValue", &SceneObject::GetGoldValue)
			.def("SetGoldValue", &SceneObject::SetGoldValue)
			.def("GetGoldValueString", &SceneObject::GetGoldValueString)
			.def("GetTotalValue", &SceneObject::GetTotalValueOld)
			.def("GetTotalValue", &SceneObject::GetTotalValue)
			.property("IsBuyable", &SceneObject::IsBuyable)
			.def("IsOnScenePoint", &SceneObject::IsOnScenePoint),*/

		ABSTRACTLUABINDING_SOL(SceneObject, Entity);

		Bind["Pos"] = sol::property(&SceneObject::GetPos, &SceneObject::SetPos);
		Bind["HFlipped"] = sol::property(&SceneObject::IsHFlipped, &SceneObject::SetHFlipped);
		Bind["RotAngle"] = sol::property(&SceneObject::GetRotAngle, &SceneObject::SetRotAngle);
		Bind["Team"] = sol::property(&SceneObject::GetTeam, &SceneObject::SetTeam);
		Bind["PlacedByPlayer"] = sol::property(&SceneObject::GetPlacedByPlayer, &SceneObject::SetPlacedByPlayer);
		Bind["GetGoldValue"] = &SceneObject::GetGoldValueOld;
		Bind["GetGoldValue"] = &SceneObject::GetGoldValue;
		Bind["SetGoldValue"] = &SceneObject::SetGoldValue;
		Bind["GetGoldValueString"] = &SceneObject::GetGoldValueString;
		Bind["GetTotalValue"] = &SceneObject::GetTotalValueOld;
		Bind["GetTotalValue"] = &SceneObject::GetTotalValue;
		Bind["IsBuyable"] = sol::property(&SceneObject::IsBuyable);
		Bind["IsOnScenePoint"] = &SceneObject::IsOnScenePoint;//*/
	}

	///////////////////////////////////////////////////////////////////////////
	// MovableObject
	///////////////////////////////////////////////////////////////////////////
	{
		/*ABSTRACTLUABINDING(MovableObject, SceneObject)
			.property("Material", &MovableObject::GetMaterial)
			.def("ReloadScripts", &MovableObject::ReloadScripts)
			.property("Mass", &MovableObject::GetMass, &MovableObject::SetMass)
			.property("Pos", &MovableObject::GetPos, &MovableObject::SetPos)
			.property("Vel", &MovableObject::GetVel, &MovableObject::SetVel)
			.property("AngularVel", &MovableObject::GetAngularVel, &MovableObject::SetAngularVel)
			.property("Radius", &MovableObject::GetRadius)
			.property("Diameter", &MovableObject::GetDiameter)
			.property("Scale", &MovableObject::GetScale, &MovableObject::SetScale)
			.property("EffectRotAngle", &MovableObject::GetEffectRotAngle, &MovableObject::SetEffectRotAngle)
			.property("GlobalAccScalar", &MovableObject::GetGlobalAccScalar, &MovableObject::SetGlobalAccScalar)
			.property("AirResistance", &MovableObject::GetAirResistance, &MovableObject::SetAirResistance)
			.property("AirThreshold", &MovableObject::GetAirThreshold, &MovableObject::SetAirThreshold)
			.property("Age", &MovableObject::GetAge, &MovableObject::SetAge)
			.property("Lifetime", &MovableObject::GetLifetime, &MovableObject::SetLifetime)
			.property("ID", &MovableObject::GetID)
			.property("UniqueID", &MovableObject::GetUniqueID)
			.property("RootID", &MovableObject::GetRootID)
			.property("MOIDFootprint", &MovableObject::GetMOIDFootprint)
			.property("Sharpness", &MovableObject::GetSharpness, &MovableObject::SetSharpness)
			.def("GetAltitude", &MovableObject::GetAltitude)
			.property("AboveHUDPos", &MovableObject::GetAboveHUDPos)
			.property("HitsMOs", &MovableObject::HitsMOs, &MovableObject::SetToHitMOs)
			.property("GetsHitByMOs", &MovableObject::GetsHitByMOs, &MovableObject::SetToGetHitByMOs)
			.property("IgnoresTeamHits", &MovableObject::IgnoresTeamHits, &MovableObject::SetIgnoresTeamHits)
			.property("IgnoresWhichTeam", &MovableObject::IgnoresWhichTeam)
			.property("IgnoreTerrain", &MovableObject::IgnoreTerrain, &MovableObject::SetIgnoreTerrain)
			.def("SetWhichMOToNotHit", &MovableObject::SetWhichMOToNotHit)
			.property("ToSettle", &MovableObject::ToSettle, &MovableObject::SetToSettle)
			.property("ToDelete", &MovableObject::ToDelete, &MovableObject::SetToDelete)
			.def("IsSetToDelete", &MovableObject::IsSetToDelete)
			.property("MissionCritical", &MovableObject::IsMissionCritical, &MovableObject::SetMissionCritical)
			.def("IsMissionCritical", &MovableObject::IsMissionCritical)
			.property("HUDVisible", &MovableObject::GetHUDVisible, &MovableObject::SetHUDVisible)
			.def("IsGeneric", &MovableObject::IsGeneric)
			.def("IsActor", &MovableObject::IsActor)
			.def("IsDevice", &MovableObject::IsDevice)
			.def("IsHeldDevice", &MovableObject::IsHeldDevice)
			.def("IsThrownDevice", &MovableObject::IsThrownDevice)
			.def("IsGold", &MovableObject::IsGold)
			.def("IsThrownDevice", &MovableObject::IsThrownDevice)
			.def("HasObject", &MovableObject::HasObject)
			.def("HasObjectInGroup", &MovableObject::HasObjectInGroup)
			.def("AddForce", &MovableObject::AddForce)
			.def("AddAbsForce", &MovableObject::AddAbsForce)
			.def("AddImpulseForce", &MovableObject::AddImpulseForce)
			.def("AddAbsImpulseForce", &MovableObject::AddAbsImpulseForce)
			.def("ClearForces", &MovableObject::ClearForces)
			.def("ClearImpulseForces", &MovableObject::ClearImpulseForces)
			.def("GetForcesCount", &MovableObject::GetForcesCount)
			.def("GetForceVector", &MovableObject::GetForceVector)
			.def("GetForceOffset", &MovableObject::GetForceOffset)
			.def("SetForceVector", &MovableObject::SetForceVector)
			.def("SetForceOffset", &MovableObject::SetForceOffset)
			.def("GetImpulsesCount", &MovableObject::GetImpulsesCount)
			.def("GetImpulseVector", &MovableObject::GetImpulseVector)
			.def("GetImpulseOffset", &MovableObject::GetImpulseOffset)
			.def("SetImpulseVector", &MovableObject::SetImpulseVector)
			.def("SetImpulseOffset", &MovableObject::SetImpulseOffset)
			.property("PinStrength", &MovableObject::GetPinStrength, &MovableObject::SetPinStrength)
			.def("RestDetection", &MovableObject::RestDetection)
			.def("NotResting", &MovableObject::NotResting)
			.def("IsAtRest", &MovableObject::IsAtRest)
			.def("MoveOutOfTerrain", &MovableObject::MoveOutOfTerrain)
			.def("RotateOffset", &MovableObject::RotateOffset)
			.property("DamageOnCollision", &MovableObject::DamageOnCollision, &MovableObject::SetDamageOnCollision)
			.property("DamageOnPenetration", &MovableObject::DamageOnPenetration, &MovableObject::SetDamageOnPenetration)
			.property("WoundDamageMultiplier", &MovableObject::WoundDamageMultiplier, &MovableObject::SetWoundDamageMultiplier)
			.property("HitWhatMOID", &MovableObject::HitWhatMOID)
			.property("HitWhatTerrMaterial", &MovableObject::HitWhatTerrMaterial)
			.property("ProvidesPieMenuContext", &MovableObject::ProvidesPieMenuContext, &MovableObject::SetProvidesPieMenuContext)
			.def_readwrite("PieMenuActor", &MovableObject::m_pPieMenuActor)
			.property("HitWhatParticleUniqueID", &MovableObject::HitWhatParticleUniqueID),*/

		///////////////////////////////////////////////////////////////////////////

		ABSTRACTLUABINDING_SOL(MovableObject, SceneObject);

		Bind["Material"] = sol::property(&MovableObject::GetMaterial);
		Bind["ReloadScripts"] = &MovableObject::ReloadScripts;
		Bind["Mass"] = sol::property(&MovableObject::GetMass, &MovableObject::SetMass);
		Bind["Pos"] = sol::property(&MovableObject::GetPos, &MovableObject::SetPos);
		Bind["Vel"] = sol::property(&MovableObject::GetVel, &MovableObject::SetVel);
		Bind["AngularVel"] = sol::property(&MovableObject::GetAngularVel, &MovableObject::SetAngularVel);
		Bind["Radius"] = sol::property(&MovableObject::GetRadius);
		Bind["Diameter"] = sol::property(&MovableObject::GetDiameter);
		Bind["Scale"] = sol::property(&MovableObject::GetScale, &MovableObject::SetScale);
		Bind["EffectRotAngle"] = sol::property(&MovableObject::GetEffectRotAngle, &MovableObject::SetEffectRotAngle);
		Bind["GlobalAccScalar"] = sol::property(&MovableObject::GetGlobalAccScalar, &MovableObject::SetGlobalAccScalar);
		Bind["AirResistance"] = sol::property(&MovableObject::GetAirResistance, &MovableObject::SetAirResistance);
		Bind["AirThreshold"] = sol::property(&MovableObject::GetAirThreshold, &MovableObject::SetAirThreshold);
		Bind["Age"] = sol::property(&MovableObject::GetAge, &MovableObject::SetAge);
		Bind["Lifetime"] = sol::property(&MovableObject::GetLifetime, &MovableObject::SetLifetime);
		Bind["ID"] = sol::property(&MovableObject::GetID);
		Bind["UniqueID"] = sol::property(&MovableObject::GetUniqueID);
		Bind["RootID"] = sol::property(&MovableObject::GetRootID);
		Bind["MOIDFootprint"] = sol::property(&MovableObject::GetMOIDFootprint);
		Bind["Sharpness"] = sol::property(&MovableObject::GetSharpness, &MovableObject::SetSharpness);
		Bind["GetAltitude"] = &MovableObject::GetAltitude;
		Bind["AboveHUDPos"] = sol::property(&MovableObject::GetAboveHUDPos);
		Bind["HitsMOs"] = sol::property(&MovableObject::HitsMOs, &MovableObject::SetToHitMOs);
		Bind["GetsHitByMOs"] = sol::property(&MovableObject::GetsHitByMOs, &MovableObject::SetToGetHitByMOs);
		Bind["IgnoresTeamHits"] = sol::property(&MovableObject::IgnoresTeamHits, &MovableObject::SetIgnoresTeamHits);
		Bind["IgnoresWhichTeam"] = sol::property(&MovableObject::IgnoresWhichTeam);
		Bind["IgnoreTerrain"] = sol::property(&MovableObject::IgnoreTerrain, &MovableObject::SetIgnoreTerrain);
		Bind["SetWhichMOToNotHit"] = &MovableObject::SetWhichMOToNotHit;
		Bind["ToSettle"] = sol::property(&MovableObject::ToSettle, &MovableObject::SetToSettle);
		Bind["ToDelete"] = sol::property(&MovableObject::ToDelete, &MovableObject::SetToDelete);
		Bind["IsSetToDelete"] = &MovableObject::IsSetToDelete;
		Bind["MissionCritical"] = sol::property(&MovableObject::IsMissionCritical, &MovableObject::SetMissionCritical);
		Bind["IsMissionCritical"] = &MovableObject::IsMissionCritical;
		Bind["HUDVisible"] = sol::property(&MovableObject::GetHUDVisible, &MovableObject::SetHUDVisible);
		Bind["IsGeneric"] = &MovableObject::IsGeneric;
		Bind["IsActor"] = &MovableObject::IsActor;
		Bind["IsDevice"] = &MovableObject::IsDevice;
		Bind["IsHeldDevice"] = &MovableObject::IsHeldDevice;
		Bind["IsThrownDevice"] = &MovableObject::IsThrownDevice;
		Bind["IsGold"] = &MovableObject::IsGold;
		Bind["IsThrownDevice"] = &MovableObject::IsThrownDevice;
		Bind["HasObject"] = &MovableObject::HasObject;
		Bind["HasObjectInGroup"] = &MovableObject::HasObjectInGroup;
		Bind["AddForce"] = &MovableObject::AddForce;
		Bind["AddAbsForce"] = &MovableObject::AddAbsForce;
		Bind["AddImpulseForce"] = &MovableObject::AddImpulseForce;
		Bind["AddAbsImpulseForce"] = &MovableObject::AddAbsImpulseForce;
		Bind["ClearForces"] = &MovableObject::ClearForces;
		Bind["ClearImpulseForces"] = &MovableObject::ClearImpulseForces;
		Bind["GetForcesCount"] = &MovableObject::GetForcesCount;
		Bind["GetForceVector"] = &MovableObject::GetForceVector;
		Bind["GetForceOffset"] = &MovableObject::GetForceOffset;
		Bind["SetForceVector"] = &MovableObject::SetForceVector;
		Bind["SetForceOffset"] = &MovableObject::SetForceOffset;
		Bind["GetImpulsesCount"] = &MovableObject::GetImpulsesCount;
		Bind["GetImpulseVector"] = &MovableObject::GetImpulseVector;
		Bind["GetImpulseOffset"] = &MovableObject::GetImpulseOffset;
		Bind["SetImpulseVector"] = &MovableObject::SetImpulseVector;
		Bind["SetImpulseOffset"] = &MovableObject::SetImpulseOffset;
		Bind["PinStrength"] = sol::property(&MovableObject::GetPinStrength, &MovableObject::SetPinStrength);
		Bind["RestDetection"] = &MovableObject::RestDetection;
		Bind["NotResting"] = &MovableObject::NotResting;
		Bind["IsAtRest"] = &MovableObject::IsAtRest;
		Bind["MoveOutOfTerrain"] = &MovableObject::MoveOutOfTerrain;
		Bind["RotateOffset"] = &MovableObject::RotateOffset;
		Bind["DamageOnCollision"] = sol::property(&MovableObject::DamageOnCollision, &MovableObject::SetDamageOnCollision);
		Bind["DamageOnPenetration"] = sol::property(&MovableObject::DamageOnPenetration, &MovableObject::SetDamageOnPenetration);
		Bind["WoundDamageMultiplier"] = sol::property(&MovableObject::WoundDamageMultiplier, &MovableObject::SetWoundDamageMultiplier);
		Bind["HitWhatMOID"] = sol::property(&MovableObject::HitWhatMOID);
		Bind["HitWhatTerrMaterial"] = sol::property(&MovableObject::HitWhatTerrMaterial);
		Bind["ProvidesPieMenuContext"] = sol::property(&MovableObject::ProvidesPieMenuContext, &MovableObject::SetProvidesPieMenuContext);
		Bind["PieMenuActor"] = sol::property(&MovableObject::GetPieMenuActor, &MovableObject::SetPieMenuActor);
		Bind["HitWhatParticleUniqueID"] = sol::property(&MovableObject::HitWhatParticleUniqueID);//*/
	}

	{
		/*class_<Material, Entity>("Material")
		.property("ID", &Material::GetId)
		.property("Restitution", &Material::GetRestitution)
		.property("Bounce", &Material::GetRestitution)
		.property("Friction", &Material::GetFriction)
		.property("Stickiness", &Material::GetStickiness)
		.property("Strength", &Material::GetStrength)
		.property("StructuralIntegrity", &Material::GetStrength)
		.property("DensityKGPerVolumeL", &Material::GetVolumeDensity)
		.property("DensityKGPerPixel", &Material::GetPixelDensity)
		.property("SettleMaterial", &Material::GetSettleMaterial)
		.property("SpawnMaterial", &Material::GetSpawnMaterial)
		.property("TransformsInto", &Material::GetSpawnMaterial)
		.property("IsScrap", &Material::IsScrap),*/

		///////////////////////////////////////////////////////////////////////////

		sol::usertype<Material> Bind = g_pSolLuaState->new_usertype<Material>("Material", sol::no_constructor);

		Bind["ID"]  = &Material::GetId;
		Bind["Restitution"]  = &Material::GetRestitution;
		Bind["Bounce"]  = &Material::GetRestitution;
		Bind["Friction"]  = &Material::GetFriction;
		Bind["Stickiness"]  = &Material::GetStickiness;
		Bind["Strength"]  = &Material::GetStrength;
		Bind["StructuralIntegrity"]  = &Material::GetStrength;
		Bind["DensityKGPerVolumeL"]  = &Material::GetVolumeDensity;
		Bind["DensityKGPerPixel"]  = &Material::GetPixelDensity;
		Bind["SettleMaterial"]  = &Material::GetSettleMaterial;
		Bind["SpawnMaterial"]  = &Material::GetSpawnMaterial;
		Bind["TransformsInto"]  = &Material::GetSpawnMaterial;
		Bind["IsScrap"]  = &Material::IsScrap;//*/
	}

	{
		//CONCRETELUABINDING(MOPixel, MovableObject),
//            .property("Material", &MOPixel::GetMaterial),
//            .property("Framerate", &MOPixel::GetFramerate, &MOPixel::SetFramerate)
//            .property("Atom", &MOPixel::GetAtom, &MOPixel:SetAtom)
//            .property("IsGold", &MOPixel::IsGold),

		///////////////////////////////////////////////////////////////////////////

		CONCRETELUABINDING_SOL(MOPixel, MovableObject);//*/
	}

	{
		/*CONCRETELUABINDING(TerrainObject, SceneObject)
			.def("GetBitmapOffset", &TerrainObject::GetBitmapOffset)
			.def("GetBitmapWidth", &TerrainObject::GetBitmapWidth)
			.def("GetBitmapHeight", &TerrainObject::GetBitmapHeight),*/

		///////////////////////////////////////////////////////////////////////////

		CONCRETELUABINDING_SOL(TerrainObject, SceneObject);

		Bind["GetBitmapOffset"] = &TerrainObject::GetBitmapOffset;
		Bind["GetBitmapWidth"] = &TerrainObject::GetBitmapWidth;
		Bind["GetBitmapHeight"] = &TerrainObject::GetBitmapHeight;//*/
	}

	{
		/*ABSTRACTLUABINDING(MOSprite, MovableObject)
			.enum_("SpriteAnimMode")
			[
				value("NOANIM", 0),
				value("ALWAYSLOOP", 1),
				value("ALWAYSRANDOM", 2),
				value("ALWAYSPINGPONG", 3),
				value("LOOPWHENMOVING", 4),
				value("LOOPWHENOPENCLOSE", 5),
				value("PINGPONGOPENCLOSE", 6)
			]
			.property("Diameter", &MOSprite::GetDiameter)
			.property("BoundingBox", &MOSprite::GetBoundingBox)
			.property("FrameCount", &MOSprite::GetFrameCount)
			.property("SpriteOffset", &MOSprite::GetSpriteOffset, &MOSprite::SetSpriteOffset)
			.property("HFlipped", &MOSprite::IsHFlipped, &MOSprite::SetHFlipped)
			.property("RotAngle", &MOSprite::GetRotAngle, &MOSprite::SetRotAngle)
			.property("AngularVel", &MOSprite::GetAngularVel, &MOSprite::SetAngularVel)
			.property("Frame", &MOSprite::GetFrame, &MOSprite::SetFrame)
			.property("SpriteAnimMode", &MOSprite::GetSpriteAnimMode, &MOSprite::SetSpriteAnimMode)
			.property("SpriteAnimDuration", &MOSprite::GetSpriteAnimDuration, &MOSprite::SetSpriteAnimDuration)
			.def("SetNextFrame", &MOSprite::SetNextFrame)
			.def("IsTooFast", &MOSprite::IsTooFast)
			.def("IsOnScenePoint", &MOSprite::IsOnScenePoint)
			.def("RotateOffset", &MOSprite::RotateOffset)
			.def("UnRotateOffset", &MOSprite::UnRotateOffset)
			.def("GetSpriteWidth", &MOSprite::GetSpriteWidth)
			.def("GetSpriteHeight", &MOSprite::GetSpriteHeight)
			.def("SetEntryWound", &MOSprite::SetEntryWound)
			.def("SetExitWound", &MOSprite::SetExitWound)
			.def("GetEntryWoundPresetName", &MOSprite::GetEntryWoundPresetName)
			.def("GetExitWoundPresetName", &MOSprite::GetExitWoundPresetName),*/

		///////////////////////////////////////////////////////////////////////////

		ABSTRACTLUABINDING_SOL(MOSprite, MovableObject);

		g_pSolLuaState->set("SpriteAnimMode", g_pSolLuaState->create_table_with(
			"NOANIM", MOSprite::SpriteAnimMode::NOANIM,
			"ALWAYSLOOP", MOSprite::SpriteAnimMode::ALWAYSLOOP,
			"ALWAYSRANDOM", MOSprite::SpriteAnimMode::ALWAYSRANDOM,
			"ALWAYSPINGPONG", MOSprite::SpriteAnimMode::ALWAYSPINGPONG,
			"LOOPWHENMOVING", MOSprite::SpriteAnimMode::LOOPWHENMOVING,
			"LOOPWHENOPENCLOSE", MOSprite::SpriteAnimMode::LOOPWHENOPENCLOSE,
			"PINGPONGOPENCLOSE", MOSprite::SpriteAnimMode::PINGPONGOPENCLOSE
		));

		Bind["Diameter"] = sol::property(&MOSprite::GetDiameter);
		Bind["BoundingBox"] = sol::property(&MOSprite::GetBoundingBox);
		Bind["FrameCount"] = sol::property(&MOSprite::GetFrameCount);
		Bind["SpriteOffset"] = sol::property(&MOSprite::GetSpriteOffset, &MOSprite::SetSpriteOffset);
		Bind["HFlipped"] = sol::property(&MOSprite::IsHFlipped, &MOSprite::SetHFlipped);
		Bind["RotAngle"] = sol::property(&MOSprite::GetRotAngle, &MOSprite::SetRotAngle);
		Bind["AngularVel"] = sol::property(&MOSprite::GetAngularVel, &MOSprite::SetAngularVel);
		Bind["Frame"] = sol::property(&MOSprite::GetFrame, &MOSprite::SetFrame);
		Bind["SpriteAnimMode"] = sol::property(&MOSprite::GetSpriteAnimMode, &MOSprite::SetSpriteAnimMode);
		Bind["SpriteAnimDuration"] = sol::property(&MOSprite::GetSpriteAnimDuration, &MOSprite::SetSpriteAnimDuration);
		Bind["SetNextFrame"] = &MOSprite::SetNextFrame;
		Bind["IsTooFast"] = &MOSprite::IsTooFast;
		Bind["IsOnScenePoint"] = &MOSprite::IsOnScenePoint;
		Bind["RotateOffset"] = &MOSprite::RotateOffset;
		Bind["UnRotateOffset"] = &MOSprite::UnRotateOffset;
		Bind["GetSpriteWidth"] = &MOSprite::GetSpriteWidth;
		Bind["GetSpriteHeight"] = &MOSprite::GetSpriteHeight;
		Bind["SetEntryWound"] = &MOSprite::SetEntryWound;
		Bind["SetExitWound"] = &MOSprite::SetExitWound;
		Bind["GetEntryWoundPresetName"] = &MOSprite::GetEntryWoundPresetName;
		Bind["GetExitWoundPresetName"] = &MOSprite::GetExitWoundPresetName;//*/
	}

	{
		/*CONCRETELUABINDING(MOSParticle, MOSprite)
			.property("Framerate", &MOSParticle::GetFramerate, &MOSParticle::SetFramerate)
			.property("IsGold", &MOSParticle::IsGold),*/

		///////////////////////////////////////////////////////////////////////////

		CONCRETELUABINDING_SOL(MOSParticle, MOSprite);
		
		Bind["Framerate"] = sol::property(&MOSParticle::GetFramerate, &MOSParticle::SetFramerate);
		Bind["IsGold"] = sol::property(&MOSParticle::IsGold);//*/
	}

	{
		/*CONCRETELUABINDING(MOSRotating, MOSprite)
			.property("RecoilForce", &MOSRotating::GetRecoilForce)
			.property("RecoilOffset", &MOSRotating::GetRecoilOffset)
			.property("IsGold", &MOSRotating::IsGold)
			.property("TravelImpulse", &MOSRotating::GetTravelImpulse, &MOSRotating::SetTravelImpulse)
			.property("GibWoundLimit", &MOSRotating::GetGibWoundLimit, &MOSRotating::SetGibWoundLimit)
			.property("GibImpulseLimit", &MOSRotating::GetGibImpulseLimit, &MOSRotating::SetGibImpulseLimit)
			.property("DamageMultiplier", &MOSRotating::GetDamageMultiplier, &MOSRotating::SetDamageMultiplier)
			.property("WoundCount", &MOSRotating::GetWoundCount)
			.def_readwrite("Wounds", &MOSRotating::m_Emitters, luabind::return_stl_iterator())
			.def("AddRecoil", &MOSRotating::AddRecoil)
			.def("SetRecoil", &MOSRotating::SetRecoil)
			.def("IsRecoiled", &MOSRotating::IsRecoiled)
			.def("EnableDeepCheck", &MOSRotating::EnableDeepCheck)
			.def("ForceDeepCheck", &MOSRotating::ForceDeepCheck)
			.def("GibThis", &MOSRotating::GibThis)
			// Free function bound as member function to emulate default variables
			.def("GibThis", &GibThis)
			.def("MoveOutOfTerrain", &MOSRotating::MoveOutOfTerrain)
			.def("ApplyForces", &MOSRotating::ApplyForces)
			.def("ApplyImpulses", &MOSRotating::ApplyImpulses)
			.def("AttachEmitter", &MOSRotating::AttachEmitter, luabind::adopt_policy<2>())
			.def("RemoveWounds", &MOSRotating::RemoveWounds)
			.def("IsOnScenePoint", &MOSRotating::IsOnScenePoint)
			.def("EraseFromTerrain", &MOSRotating::EraseFromTerrain)
			.def("GetStringValue", &MOSRotating::GetStringValue)
			.def("GetNumberValue", &MOSRotating::GetNumberValue)
			.def("GetObjectValue", &MOSRotating::GetObjectValue)
			.def("SetStringValue", &MOSRotating::SetStringValue)
			.def("SetNumberValue", &MOSRotating::SetNumberValue)
			.def("SetObjectValue", &MOSRotating::SetObjectValue)
			.def("RemoveStringValue", &MOSRotating::RemoveStringValue)
			.def("RemoveNumberValue", &MOSRotating::RemoveNumberValue)
			.def("RemoveObjectValue", &MOSRotating::RemoveObjectValue)
			.def("StringValueExists", &MOSRotating::StringValueExists)
			.def("NumberValueExists", &MOSRotating::NumberValueExists)
			.def("ObjectValueExists", &MOSRotating::ObjectValueExists)
			.def_readwrite("Attachables", &MOSRotating::m_Attachables, luabind::return_stl_iterator())
			.def_readwrite("Emitters", &MOSRotating::m_Emitters, luabind::return_stl_iterator()),*/

		///////////////////////////////////////////////////////////////////////////

		CONCRETELUABINDING_SOL(MOSRotating, MOSprite);

		Bind["RecoilForce"] = sol::property(&MOSRotating::GetRecoilForce);
		Bind["RecoilOffset"] = sol::property(&MOSRotating::GetRecoilOffset);
		Bind["IsGold"] = sol::property(&MOSRotating::IsGold);
		Bind["TravelImpulse"] = sol::property(&MOSRotating::GetTravelImpulse, &MOSRotating::SetTravelImpulse);
		Bind["GibWoundLimit"] = sol::property(&MOSRotating::GetGibWoundLimit, &MOSRotating::SetGibWoundLimit);
		Bind["GibImpulseLimit"] = sol::property(&MOSRotating::GetGibImpulseLimit, &MOSRotating::SetGibImpulseLimit);
		Bind["DamageMultiplier"] = sol::property(&MOSRotating::GetDamageMultiplier, &MOSRotating::SetDamageMultiplier);
		Bind["WoundCount"] = sol::property(&MOSRotating::GetWoundCount);
		Bind["AddRecoil"] = &MOSRotating::AddRecoil;
		Bind["SetRecoil"] = &MOSRotating::SetRecoil;
		Bind["IsRecoiled"] = &MOSRotating::IsRecoiled;
		Bind["EnableDeepCheck"] = &MOSRotating::EnableDeepCheck;
		Bind["ForceDeepCheck"] = &MOSRotating::ForceDeepCheck;
		Bind["GibThis"] = &MOSRotating::GibThis;
		// Free function bound as member function to emulate default variables
		//Bind["GibThis"] = &GibThis;
		Bind["MoveOutOfTerrain"] = &MOSRotating::MoveOutOfTerrain;
		Bind["ApplyForces"] = &MOSRotating::ApplyForces;
		Bind["ApplyImpulses"] = &MOSRotating::ApplyImpulses;
		Bind["AttachEmitter"] = &MOSRotating::AttachEmitter;
		Bind["RemoveWounds"] = &MOSRotating::RemoveWounds;
		Bind["IsOnScenePoint"] = &MOSRotating::IsOnScenePoint;
		Bind["EraseFromTerrain"] = &MOSRotating::EraseFromTerrain;
		Bind["GetStringValue"] = &MOSRotating::GetStringValue;
		Bind["GetNumberValue"] = &MOSRotating::GetNumberValue;
		Bind["GetObjectValue"] = &MOSRotating::GetObjectValue;
		Bind["SetStringValue"] = &MOSRotating::SetStringValue;
		Bind["SetNumberValue"] = &MOSRotating::SetNumberValue;
		Bind["SetObjectValue"] = &MOSRotating::SetObjectValue;
		Bind["RemoveStringValue"] = &MOSRotating::RemoveStringValue;
		Bind["RemoveNumberValue"] = &MOSRotating::RemoveNumberValue;
		Bind["RemoveObjectValue"] = &MOSRotating::RemoveObjectValue;
		Bind["StringValueExists"] = &MOSRotating::StringValueExists;
		Bind["NumberValueExists"] = &MOSRotating::NumberValueExists;
		Bind["ObjectValueExists"] = &MOSRotating::ObjectValueExists;
		Bind["Wounds"] = &MOSRotating::m_Emitters;
		Bind["Attachables"] = &MOSRotating::m_Attachables;
		Bind["Emitters"] = &MOSRotating::m_Emitters;//*/
	}

	{
		/*CONCRETELUABINDING(Attachable, MOSRotating)
			.def("GetRootParent", (MovableObject * (Attachable::*)())&Attachable::GetRootParent)
			.def("GetRootParent", (const MovableObject * (Attachable::*)() const)&Attachable::GetRootParent)
			.def("GetParent", (MovableObject * (Attachable::*)())&Attachable::GetParent)
			.def("GetParent", (const MovableObject * (Attachable::*)() const)&Attachable::GetParent)
			.property("ParentOffset", &Attachable::GetParentOffset, &Attachable::SetParentOffset)
			.property("JointOffset", &Attachable::GetJointOffset, &Attachable::SetJointOffset)
			.property("JointStiffness", &Attachable::GetJointStiffness, &Attachable::SetJointStiffness)
			.property("JointStrength", &Attachable::GetJointStrength, &Attachable::SetJointStrength)
			.property("RotTarget", &Attachable::GetRotTarget, &Attachable::SetRotTarget)
			.property("AtomSubgroupID", &Attachable::GetAtomSubgroupID, &Attachable::SetAtomSubgroupID)
			.property("OnlyLinearForces", &Attachable::GetOnlyLinearForces, &Attachable::SetOnlyLinearForces)
			.def("IsAttached", &Attachable::IsAttached)
			.def("IsAttachedTo", &Attachable::IsAttachedTo)
			.def("IsDrawnAfterParent", &Attachable::IsDrawnAfterParent)
			.def("Attach", (void (Attachable::*)(MOSRotating *))&Attachable::Attach)
			.def("Attach", (void (Attachable::*)(MOSRotating *, const Vector &))&Attachable::Attach)
			.def("Detach", &Attachable::Detach)
			.def("TransferJointForces", &Attachable::TransferJointForces)
			.def("TransferJointImpulses", &Attachable::TransferJointImpulses)
			.def("CollectDamage", &Attachable::CollectDamage)
			.property("InheritsRotAngle", &Attachable::InheritsRotAngle, &Attachable::SetInheritsRotAngle),*/

		///////////////////////////////////////////////////////////////////////////

		CONCRETELUABINDING_SOL(Attachable, MOSRotating);

		Bind["GetRootParent"] = (MovableObject * (Attachable::*)())&Attachable::GetRootParent;
		Bind["GetRootParent"] = (const MovableObject * (Attachable::*)() const)&Attachable::GetRootParent;
		Bind["GetParent"] = (MovableObject * (Attachable::*)())&Attachable::GetParent;
		Bind["GetParent"] = (const MovableObject * (Attachable::*)() const)&Attachable::GetParent;
		Bind["ParentOffset"] = sol::property(&Attachable::GetParentOffset, &Attachable::SetParentOffset);
		Bind["JointOffset"] = sol::property(&Attachable::GetJointOffset, &Attachable::SetJointOffset);
		Bind["JointStiffness"] = sol::property(&Attachable::GetJointStiffness, &Attachable::SetJointStiffness);
		Bind["JointStrength"] = sol::property(&Attachable::GetJointStrength, &Attachable::SetJointStrength);
		Bind["RotTarget"] = sol::property(&Attachable::GetRotTarget, &Attachable::SetRotTarget);
		Bind["AtomSubgroupID"] = sol::property(&Attachable::GetAtomSubgroupID, &Attachable::SetAtomSubgroupID);
		Bind["OnlyLinearForces"] = sol::property(&Attachable::GetOnlyLinearForces, &Attachable::SetOnlyLinearForces);
		Bind["IsAttached"] = &Attachable::IsAttached;
		Bind["IsAttachedTo"] = &Attachable::IsAttachedTo;
		Bind["IsDrawnAfterParent"] = &Attachable::IsDrawnAfterParent;
		Bind["Attach"] = (void (Attachable::*)(MOSRotating *))&Attachable::Attach;
		Bind["Attach"] = (void (Attachable::*)(MOSRotating *, const Vector &))&Attachable::Attach;
		Bind["Detach"] = &Attachable::Detach;
		Bind["TransferJointForces"] = &Attachable::TransferJointForces;
		Bind["TransferJointImpulses"] = &Attachable::TransferJointImpulses;
		Bind["CollectDamage"] = &Attachable::CollectDamage;
		Bind["InheritsRotAngle"] = sol::property(&Attachable::InheritsRotAngle, &Attachable::SetInheritsRotAngle);//*/
	}

	{
		/*ABSTRACTLUABINDING(Emission, Entity)
			.property("ParticlesPerMinute", &Emission::GetRate, &Emission::SetRate)
			.property("MinVelocity", &Emission::GetMinVelocity, &Emission::SetMinVelocity)
			.property("MaxVelocity", &Emission::GetMaxVelocity, &Emission::SetMaxVelocity)
			.property("PushesEmitter", &Emission::PushesEmitter, &Emission::SetPushesEmitter)
			.property("LifeVariation", &Emission::GetLifeVariation, &Emission::SetLifeVariation)
			.property("BurstSize", &Emission::GetBurstSize, &Emission::SetBurstSize)
			.property("Spread", &Emission::GetSpread, &Emission::SetSpread)
			.property("Offset", &Emission::GetOffset, &Emission::SetOffset)
			.def("ResetEmissionTimers", &Emission::ResetEmissionTimers),*/

		///////////////////////////////////////////////////////////////////////////

		ABSTRACTLUABINDING_SOL(Emission, Entity);

		Bind["ParticlesPerMinute"] = sol::property(&Emission::GetRate, &Emission::SetRate);
		Bind["MinVelocity"] = sol::property(&Emission::GetMinVelocity, &Emission::SetMinVelocity);
		Bind["MaxVelocity"] = sol::property(&Emission::GetMaxVelocity, &Emission::SetMaxVelocity);
		Bind["PushesEmitter"] = sol::property(&Emission::PushesEmitter, &Emission::SetPushesEmitter);
		Bind["LifeVariation"] = sol::property(&Emission::GetLifeVariation, &Emission::SetLifeVariation);
		Bind["BurstSize"] = sol::property(&Emission::GetBurstSize, &Emission::SetBurstSize);
		Bind["Spread"] = sol::property(&Emission::GetSpread, &Emission::SetSpread);
		Bind["Offset"] = sol::property(&Emission::GetOffset, &Emission::SetOffset);
		Bind["ResetEmissionTimers"] = &Emission::ResetEmissionTimers;//*/
	}

	{
		/*CONCRETELUABINDING(AEmitter, Attachable)
			.def("IsEmitting", &AEmitter::IsEmitting)
			.def("EnableEmission", &AEmitter::EnableEmission)
			.property("BurstScale", &AEmitter::GetBurstScale, &AEmitter::SetBurstScale)
			.property("EmitAngle", &AEmitter::GetEmitAngle, &AEmitter::SetEmitAngle)
			.property("GetThrottle", &AEmitter::GetThrottle, &AEmitter::SetThrottle)
			.property("Throttle", &AEmitter::GetThrottle, &AEmitter::SetThrottle)
			.property("BurstSpacing", &AEmitter::GetBurstSpacing, &AEmitter::SetBurstSpacing)
			.property("BurstDamage", &AEmitter::GetBurstDamage, &AEmitter::SetBurstDamage)
			.property("EmitterDamageMultiplier", &AEmitter::GetEmitterDamageMultiplier, &AEmitter::SetEmitterDamageMultiplier)
			.property("EmitCountLimit", &AEmitter::GetEmitCountLimit, &AEmitter::SetEmitCountLimit)
			.property("EmitDamage", &AEmitter::GetEmitDamage, &AEmitter::SetEmitDamage)
			.property("FlashScale", &AEmitter::GetFlashScale, &AEmitter::SetFlashScale)
			.def("GetEmitVector", &AEmitter::GetEmitVector)
			.def("GetRecoilVector", &AEmitter::GetRecoilVector)
			.def("EstimateImpulse", &AEmitter::EstimateImpulse)
			.def("TriggerBurst", &AEmitter::TriggerBurst)
			.def("IsSetToBurst", &AEmitter::IsSetToBurst)
			.def("CanTriggerBurst", &AEmitter::CanTriggerBurst)
			.def_readwrite("Emissions", &AEmitter::m_EmissionList, luabind::return_stl_iterator()),*/

		///////////////////////////////////////////////////////////////////////////

		CONCRETELUABINDING_SOL(AEmitter, Attachable)

		Bind["IsEmitting"] = &AEmitter::IsEmitting;
		Bind["EnableEmission"] = &AEmitter::EnableEmission;
		Bind["BurstScale"] = sol::property(&AEmitter::GetBurstScale, &AEmitter::SetBurstScale);
		Bind["EmitAngle"] = sol::property(&AEmitter::GetEmitAngle, &AEmitter::SetEmitAngle);
		Bind["GetThrottle"] = sol::property(&AEmitter::GetThrottle, &AEmitter::SetThrottle);
		Bind["Throttle"] = sol::property(&AEmitter::GetThrottle, &AEmitter::SetThrottle);
		Bind["BurstSpacing"] = sol::property(&AEmitter::GetBurstSpacing, &AEmitter::SetBurstSpacing);
		Bind["BurstDamage"] = sol::property(&AEmitter::GetBurstDamage, &AEmitter::SetBurstDamage);
		Bind["EmitterDamageMultiplier"] = sol::property(&AEmitter::GetEmitterDamageMultiplier, &AEmitter::SetEmitterDamageMultiplier);
		Bind["EmitCountLimit"] = sol::property(&AEmitter::GetEmitCountLimit, &AEmitter::SetEmitCountLimit);
		Bind["EmitDamage"] = sol::property(&AEmitter::GetEmitDamage, &AEmitter::SetEmitDamage);
		Bind["FlashScale"] = sol::property(&AEmitter::GetFlashScale, &AEmitter::SetFlashScale);
		Bind["GetEmitVector"] = &AEmitter::GetEmitVector;
		Bind["GetRecoilVector"] = &AEmitter::GetRecoilVector;
		Bind["EstimateImpulse"] = &AEmitter::EstimateImpulse;
		Bind["TriggerBurst"] = &AEmitter::TriggerBurst;
		Bind["IsSetToBurst"] = &AEmitter::IsSetToBurst;
		Bind["CanTriggerBurst"] = &AEmitter::CanTriggerBurst;
		Bind["Emissions"] = &AEmitter::m_EmissionList;//*/
	}

	{
		/*CONCRETELUABINDING(Actor, MOSRotating)
			.enum_("Status")
			[
				value("STABLE", 0),
				value("UNSTABLE", 1),
				value("INACTIVE", 2),
				value("DYING", 3),
				value("DEAD", 4)
			]
			.enum_("AIMode")
			[
				value("AIMODE_NONE", 0),
				value("AIMODE_SENTRY", 1),
				value("AIMODE_PATROL", 2),
				value("AIMODE_GOTO", 3),
				value("AIMODE_BRAINHUNT", 4),
				value("AIMODE_GOLDDIG", 5),
				value("AIMODE_RETURN", 6),
				value("AIMODE_STAY", 7),
				value("AIMODE_SCUTTLE", 8),
				value("AIMODE_DELIVER", 9),
				value("AIMODE_BOMB", 10),
				value("AIMODE_SQUAD", 11),
				value("AIMODE_COUNT", 12)
			]
		.enum_("ActionState")
			[
				value("MOVING", 0),
				value("MOVING_FAST", 1),
				value("FIRING", 2),
				value("ActionStateCount", 3)
			]
		.enum_("AimState")
			[
				value("AIMSTILL", 0),
				value("AIMUP", 1),
				value("AIMDOWN", 2),
				value("AimStateCount", 3)
			]
		.enum_("LateralMoveState")
			[
				value("LAT_STILL", 0),
				value("LAT_LEFT", 1),
				value("LAT_RIGHT", 2)
			]
		.enum_("ObstacleState")
			[
				value("PROCEEDING", 0),
				value("BACKSTEPPING", 1),
				value("DIGPAUSING", 2),
				value("JUMPING", 3),
				value("SOFTLANDING", 4)
			]
		.enum_("TeamBlockState")
			[
				value("NOTBLOCKED", 0),
				value("BLOCKED", 1),
				value("IGNORINGBLOCK", 2),
				value("FOLLOWWAIT", 3)
			]
		.def(constructor<>())
			.def("GetController", &Actor::GetController)
			.def("IsPlayerControlled", &Actor::IsPlayerControlled)
			.def("IsControllable", &Actor::IsControllable)
			.def("SetControllerMode", &Actor::SetControllerMode)
			.def("SwapControllerModes", &Actor::SwapControllerModes)
			.property("ImpulseDamageThreshold", &Actor::GetTravelImpulseDamage, &Actor::SetTravelImpulseDamage)
			.property("Status", &Actor::GetStatus, &Actor::SetStatus)
			.property("Health", &Actor::GetHealth, &Actor::SetHealth)
			.property("MaxHealth", &Actor::GetMaxHealth, &Actor::SetMaxHealth)
			.property("GoldCarried", &Actor::GetGoldCarried, &Actor::SetGoldCarried)
			.property("AimRange", &Actor::GetAimRange, &Actor::SetAimRange)
			.def("GetAimAngle", &Actor::GetAimAngle)
			.def("SetAimAngle", &Actor::SetAimAngle)
			.def("HasObject", &Actor::HasObject)
			.def("HasObjectInGroup", &Actor::HasObjectInGroup)
			.property("CPUPos", &Actor::GetCPUPos)
			.property("EyePos", &Actor::GetEyePos)
			.property("ViewPoint", &Actor::GetViewPoint, &Actor::SetViewPoint)
			.property("Height", &Actor::GetHeight)
			.def("IsWithinRange", &Actor::IsWithinRange)
			.def("AddHealth", &Actor::AddHealth)
			.def("IsStatus", &Actor::IsStatus)
			.def("IsDead", &Actor::IsDead)
			.def("FacingAngle", &Actor::FacingAngle)
			.property("AIMode", &Actor::GetAIMode, &Actor::SetAIMode)
			.property("DeploymentID", &Actor::GetDeploymentID)
			.def("AddAISceneWaypoint", &Actor::AddAISceneWaypoint)
			.def("AddAIMOWaypoint", &Actor::AddAIMOWaypoint)
			.def("ClearAIWaypoints", &Actor::ClearAIWaypoints)
			.def("GetLastAIWaypoint", &Actor::GetLastAIWaypoint)
			.def("GetAIMOWaypointID", &Actor::GetAIMOWaypointID)
			.def("GetWaypointListSize", &Actor::GetWaypointsSize)
			.def("ClearMovePath", &Actor::ClearMovePath)
			.def("AddToMovePathBeginning", &Actor::AddToMovePathBeginning)
			.def("AddToMovePathEnd", &Actor::AddToMovePathEnd)
			.def("RemoveMovePathBeginning", &Actor::RemoveMovePathBeginning)
			.def("RemoveMovePathEnd", &Actor::RemoveMovePathEnd)
			.property("Perceptiveness", &Actor::GetPerceptiveness, &Actor::SetPerceptiveness)
			.def("AddInventoryItem", &Actor::AddInventoryItem, luabind::adopt_policy<2>())
			.def("RemoveInventoryItem", &Actor::RemoveInventoryItem)
			.def("SwapNextInventory", &Actor::SwapNextInventory)
			.def("SwapPrevInventory", &Actor::SwapPrevInventory)
			.def("DropAllInventory", &Actor::DropAllInventory)
			.property("InventorySize", &Actor::GetInventorySize)
			.def("IsInventoryEmpty", &Actor::IsInventoryEmpty)
			.property("MaxMass", &Actor::GetMaxMass)
			.def("FlashWhite", &Actor::FlashWhite)
			.def("DrawWaypoints", &Actor::DrawWaypoints)
			.def("SetMovePathToUpdate", &Actor::SetMovePathToUpdate)
			.def("UpdateMovePath", &Actor::UpdateMovePath)
			.property("MovePathSize", &Actor::GetMovePathSize)
			.def_readwrite("MOMoveTarget", &Actor::m_pMOMoveTarget)
			.def_readwrite("MovePath", &Actor::m_MovePath, luabind::return_stl_iterator())
			.def_readwrite("Inventory", &Actor::m_Inventory, luabind::return_stl_iterator())
			.def("SetAlarmPoint", &Actor::AlarmPoint)
			.def("GetAlarmPoint", &Actor::GetAlarmPoint)
			.property("AimDistance", &Actor::GetAimDistance, &Actor::SetAimDistance)
			.property("SightDistance", &Actor::GetSightDistance, &Actor::SetSightDistance)
			.property("TotalWoundCount", &Actor::GetTotalWoundCount)
			.property("TotalWoundLimit", &Actor::GetTotalWoundLimit)
			.def("RemoveAnyRandomWounds", &Actor::RemoveAnyRandomWounds),*/

		///////////////////////////////////////////////////////////////////////////

		CONCRETELUABINDING_SOL(Actor, MOSRotating);

		g_pSolLuaState->set("Status", g_pSolLuaState->create_table_with(
			"STABLE", Actor::Status::STABLE,
			"UNSTABLE", Actor::Status::UNSTABLE,
			"INACTIVE", Actor::Status::INACTIVE,
			"DYING", Actor::Status::DYING,
			"DEAD", Actor::Status::DEAD
		));

		g_pSolLuaState->set("AIMode", g_pSolLuaState->create_table_with(
			"AIMODE_NONE", Actor::AIMode::AIMODE_NONE,
			"AIMODE_SENTRY", Actor::AIMode::AIMODE_SENTRY,
			"AIMODE_PATROL", Actor::AIMode::AIMODE_PATROL,
			"AIMODE_GOTO", Actor::AIMode::AIMODE_GOTO,
			"AIMODE_BRAINHUNT", Actor::AIMode::AIMODE_BRAINHUNT,
			"AIMODE_GOLDDIG", Actor::AIMode::AIMODE_GOLDDIG,
			"AIMODE_RETURN", Actor::AIMode::AIMODE_RETURN,
			"AIMODE_STAY", Actor::AIMode::AIMODE_STAY,
			"AIMODE_SCUTTLE", Actor::AIMode::AIMODE_SCUTTLE,
			"AIMODE_DELIVER", Actor::AIMode::AIMODE_DELIVER,
			"AIMODE_BOMB", Actor::AIMode::AIMODE_BOMB,
			"AIMODE_SQUAD", Actor::AIMode::AIMODE_SQUAD,
			"AIMODE_COUNT", Actor::AIMode::AIMODE_COUNT
		));

		g_pSolLuaState->set("ActionState", g_pSolLuaState->create_table_with(
			"MOVING", Actor::ActionState::MOVING,
			"MOVING_FAST", Actor::ActionState::MOVING_FAST,
			"FIRING", Actor::ActionState::FIRING,
			"ActionStateCount", Actor::ActionState::ActionStateCount
		));

		g_pSolLuaState->set("AimState", g_pSolLuaState->create_table_with(
			"AIMSTILL", Actor::AimState::AIMSTILL,
			"AIMUP", Actor::AimState::AIMUP,
			"AIMDOWN", Actor::AimState::AIMDOWN,
			"AimStateCount", Actor::AimState::AimStateCount
		));

		g_pSolLuaState->set("LateralMoveState", g_pSolLuaState->create_table_with(
			"LAT_STILL", Actor::LateralMoveState::LAT_STILL,
			"LAT_LEFT", Actor::LateralMoveState::LAT_LEFT,
			"LAT_RIGHT", Actor::LateralMoveState::LAT_RIGHT
		));

		g_pSolLuaState->set("ObstacleState", g_pSolLuaState->create_table_with(
			"PROCEEDING", Actor::ObstacleState::PROCEEDING,
			"BACKSTEPPING", Actor::ObstacleState::BACKSTEPPING,
			"DIGPAUSING", Actor::ObstacleState::DIGPAUSING,
			"JUMPING", Actor::ObstacleState::JUMPING,
			"SOFTLANDING", Actor::ObstacleState::SOFTLANDING
		));

		g_pSolLuaState->set("TeamBlockState", g_pSolLuaState->create_table_with(
			"NOTBLOCKED", Actor::TeamBlockState::NOTBLOCKED,
			"BLOCKED", Actor::TeamBlockState::BLOCKED,
			"IGNORINGBLOCK", Actor::TeamBlockState::IGNORINGBLOCK,
			"FOLLOWWAIT", Actor::TeamBlockState::FOLLOWWAIT
		));

		Bind["GetController"] = &Actor::GetController;
		Bind["IsPlayerControlled"] = &Actor::IsPlayerControlled;
		Bind["IsControllable"] = &Actor::IsControllable;
		Bind["SetControllerMode"] = &Actor::SetControllerMode;
		Bind["SwapControllerModes"] = &Actor::SwapControllerModes;
		Bind["ImpulseDamageThreshold"] = sol::property(&Actor::GetTravelImpulseDamage, &Actor::SetTravelImpulseDamage);
		Bind["Status"] = sol::property(&Actor::GetStatus, &Actor::SetStatus);
		Bind["Health"] = sol::property(&Actor::GetHealth, &Actor::SetHealth);
		Bind["MaxHealth"] = sol::property(&Actor::GetMaxHealth, &Actor::SetMaxHealth);
		Bind["GoldCarried"] = sol::property(&Actor::GetGoldCarried, &Actor::SetGoldCarried);
		Bind["AimRange"] = sol::property(&Actor::GetAimRange, &Actor::SetAimRange);
		Bind["GetAimAngle"] = &Actor::GetAimAngle;
		Bind["SetAimAngle"] = &Actor::SetAimAngle;
		Bind["HasObject"] = &Actor::HasObject;
		Bind["HasObjectInGroup"] = &Actor::HasObjectInGroup;
		Bind["CPUPos"] = sol::property(&Actor::GetCPUPos);
		Bind["EyePos"] = sol::property(&Actor::GetEyePos);
		Bind["ViewPoint"] = sol::property(&Actor::GetViewPoint, &Actor::SetViewPoint);
		Bind["Height"] = sol::property(&Actor::GetHeight);
		Bind["IsWithinRange"] = &Actor::IsWithinRange;
		Bind["AddHealth"] = &Actor::AddHealth;
		Bind["IsStatus"] = &Actor::IsStatus;
		Bind["IsDead"] = &Actor::IsDead;
		Bind["FacingAngle"] = &Actor::FacingAngle;
		Bind["AIMode"] = sol::property(&Actor::GetAIMode, &Actor::SetAIMode);
		Bind["DeploymentID"] = sol::property(&Actor::GetDeploymentID);
		Bind["AddAISceneWaypoint"] = &Actor::AddAISceneWaypoint;
		Bind["AddAIMOWaypoint"] = &Actor::AddAIMOWaypoint;
		Bind["ClearAIWaypoints"] = &Actor::ClearAIWaypoints;
		Bind["GetLastAIWaypoint"] = &Actor::GetLastAIWaypoint;
		Bind["GetAIMOWaypointID"] = &Actor::GetAIMOWaypointID;
		Bind["GetWaypointListSize"] = &Actor::GetWaypointsSize;
		Bind["ClearMovePath"] = &Actor::ClearMovePath;
		Bind["AddToMovePathBeginning"] = &Actor::AddToMovePathBeginning;
		Bind["AddToMovePathEnd"] = &Actor::AddToMovePathEnd;
		Bind["RemoveMovePathBeginning"] = &Actor::RemoveMovePathBeginning;
		Bind["RemoveMovePathEnd"] = &Actor::RemoveMovePathEnd;
		Bind["Perceptiveness"] = sol::property(&Actor::GetPerceptiveness, &Actor::SetPerceptiveness);
		Bind["AddInventoryItem"] = &Actor::AddInventoryItem;
		Bind["RemoveInventoryItem"] = &Actor::RemoveInventoryItem;
		Bind["SwapNextInventory"] = &Actor::SwapNextInventory;
		Bind["SwapPrevInventory"] = &Actor::SwapPrevInventory;
		Bind["DropAllInventory"] = &Actor::DropAllInventory;
		Bind["InventorySize"] = sol::property(&Actor::GetInventorySize);
		Bind["IsInventoryEmpty"] = &Actor::IsInventoryEmpty;
		Bind["MaxMass"] = sol::property(&Actor::GetMaxMass);
		Bind["FlashWhite"] = &Actor::FlashWhite;
		Bind["DrawWaypoints"] = &Actor::DrawWaypoints;
		Bind["SetMovePathToUpdate"] = &Actor::SetMovePathToUpdate;
		Bind["UpdateMovePath"] = &Actor::UpdateMovePath;
		Bind["MovePathSize"] = sol::property(&Actor::GetMovePathSize);
		Bind["MOMoveTarget"] = &Actor::m_pMOMoveTarget;
		Bind["MovePath"] = &Actor::m_MovePath;
		Bind["Inventory"] = &Actor::m_Inventory;
		Bind["SetAlarmPoint"] = &Actor::AlarmPoint;
		Bind["GetAlarmPoint"] = &Actor::GetAlarmPoint;
		Bind["AimDistance"] = sol::property(&Actor::GetAimDistance, &Actor::SetAimDistance);
		Bind["SightDistance"] = sol::property(&Actor::GetSightDistance, &Actor::SetSightDistance);
		Bind["TotalWoundCount"] = sol::property(&Actor::GetTotalWoundCount);
		Bind["TotalWoundLimit"] = sol::property(&Actor::GetTotalWoundLimit);
		Bind["RemoveAnyRandomWounds"] = &Actor::RemoveAnyRandomWounds;//*/
	}


	{
		/*CONCRETELUABINDING(ADoor, Actor)
		.enum_("DooorState")
		[
			value("CLOSED", 0),
			value("OPENING", 1),
			value("OPEN", 2),
			value("CLOSING", 3)
		]
		.property("Door", &ADoor::GetDoor)
		.def("GetDoorState", &ADoor::GetDoorState)
		.def("OpenDoor", &ADoor::OpenDoor)
		.def("CloseDoor", &ADoor::CloseDoor)
		.def("SetClosedByDefault", &ADoor::SetClosedByDefault),*/

		///////////////////////////////////////////////////////////////////////////

		CONCRETELUABINDING_SOL(ADoor, Actor)

		g_pSolLuaState->set("DooorState", g_pSolLuaState->create_table_with(
			"CLOSED", ADoor::DoorState::CLOSED,
			"OPENING", ADoor::DoorState::OPENING,
			"OPEN", ADoor::DoorState::OPEN,
			"CLOSING", ADoor::DoorState::CLOSING
		));
		Bind["Door"] = sol::property(&ADoor::GetDoor);
		Bind["GetDoorState"] = &ADoor::GetDoorState;
		Bind["OpenDoor"] = &ADoor::OpenDoor;
		Bind["CloseDoor"] = &ADoor::CloseDoor;
		Bind["SetClosedByDefault"] = &ADoor::SetClosedByDefault;//*/
	}
	
	{
		/*ABSTRACTLUABINDING(Arm, Attachable)
			.property("IdleOffset", &Arm::GetIdleOffset, &Arm::SetIdleOffset)
			.property("HandPos", &Arm::GetHandPos, &Arm::SetHandPos),*/

		///////////////////////////////////////////////////////////////////////////

		ABSTRACTLUABINDING_SOL(Arm, Attachable);

		Bind["IdleOffset"] = sol::property(&Arm::GetIdleOffset, &Arm::SetIdleOffset);
		Bind["HandPos"] = sol::property(&Arm::GetHandPos, &Arm::SetHandPos);//*/
	}


	{
		/*CONCRETELUABINDING(AHuman, Actor)
			.enum_("UpperBodyState")
			[
				value("WEAPON_READY", 0),
				value("AIMING_SHARP", 1),
				value("HOLSTERING_BACK", 2),
				value("HOLSTERING_BELT", 3),
				value("DEHOLSTERING_BACK", 4),
				value("DEHOLSTERING_BELT", 5),
				value("THROWING_PREP", 6),
				value("THROWING_RELEASE", 7)
			]
			.enum_("MovementState")
			[
				value("NOMOVE", 0),
				value("STAND", 1),
				value("WALK", 2),
				value("CROUCH", 3),
				value("CRAWL", 4),
				value("ARMCRAWL", 5),
				value("CLIMB", 6),
				value("JUMP", 7),
				value("DISLODGE", 8),
				value("MOMENTSTATECOUNT", 9)
			]
			.enum_("ProneState")
			[
				value("NOTPRONE", 0),
				value("GOPRONE", 1),
				value("PRONE", 2),
				value("PRONESTATECOUNT", 3)
			]
			.enum_("Layer")
			[
				value("FGROUND", 0),
				value("BGROUND", 1)
			]
			.enum_("DeviceHandlingState")
			[
				value("STILL", 0),
				value("POINTING", 1),
				value("SCANNING", 2),
				value("AIMING", 3),
				value("FIRING", 4),
				value("THROWING", 5),
				value("DIGGING", 6)
			]
			.enum_("SweepState")
			[
				value("NOSWEEP", 0),
				value("SWEEPINGUP", 1),
				value("SWEEPINGPAUSE", 2),
				value("SWEEPINGDOWN", 3),
				value("SWEEMDOWNPAUSE", 4)
			]
			.enum_("DigState")
			[
				value("NOTDIGGING", 0),
				value("PREDIG", 1),
				value("STARTDIG", 2),
				value("TUNNELING", 3),
				value("FINISHINGDIG", 4),
				value("PAUSEDIGGER", 5)
			]
			.enum_("JumpState")
			[
				value("NOTJUMPING", 0),
				value("FORWARDJUMP", 1),
				value("PREJUMP", 2),
				value("UPJUMP", 3),
				value("APEXJUMP", 4),
				value("LANDJUMP", 5)
			]
			.def(constructor<>())
			.property("Head", &AHuman::GetHead)
			.property("FGArm", &AHuman::GetFGArm)
			.property("BGArm", &AHuman::GetBGArm)
			.property("FGLeg", &AHuman::GetFGLeg)
			.property("BGLeg", &AHuman::GetBGLeg)
			.property("Jetpack", &AHuman::GetJetpack)
			.property("JetTimeTotal", &AHuman::GetJetTimeTotal, &AHuman::SetJetTimeTotal)
			.property("JetTimeLeft", &AHuman::GetJetTimeLeft, &AHuman::SetJetTimeLeft)
			.def("EquipFirearm", &AHuman::EquipFirearm)
			.def("EquipThrowable", &AHuman::EquipThrowable)
			.def("EquipDiggingTool", &AHuman::EquipDiggingTool)
			.def("EquipShield", &AHuman::EquipShield)
			.def("EquipShieldInBGArm", &AHuman::EquipShieldInBGArm)
			.def("EquipDeviceInGroup", &AHuman::EquipDeviceInGroup)
			.def("EquipNamedDevice", &AHuman::EquipNamedDevice)
			.def("EquipLoadedFirearmInGroup", &AHuman::EquipLoadedFirearmInGroup)
			.def("UnequipBGArm", &AHuman::UnequipBGArm)
			.property("EquippedItem", &AHuman::GetEquippedItem)
			.property("EquippedBGItem", &AHuman::GetEquippedBGItem)
			.property("FirearmIsReady", &AHuman::FirearmIsReady)
			.property("ThrowableIsReady", &AHuman::ThrowableIsReady)
			.property("FirearmIsEmpty", &AHuman::FirearmIsEmpty)
			.property("FirearmNeedsReload", &AHuman::FirearmNeedsReload)
			.property("FirearmIsSemiAuto", &AHuman::FirearmIsSemiAuto)
			.property("FirearmActivationDelay", &AHuman::FirearmActivationDelay)
			.def("ReloadFirearm", &AHuman::ReloadFirearm)
			.def("IsWithinRange", &AHuman::IsWithinRange)
			.def("Look", &AHuman::Look)
			.def("LookForGold", &AHuman::LookForGold)
			.def("LookForMOs", &AHuman::LookForMOs)
			.def("IsOnScenePoint", &AHuman::IsOnScenePoint)
			.property("LimbPathPushForce", &AHuman::GetLimbPathPushForce, &AHuman::SetLimbPathPushForce)
			.def("GetLimbPathSpeed", &AHuman::GetLimbPathSpeed)
			.def("SetLimbPathSpeed", &AHuman::SetLimbPathSpeed),*/

		///////////////////////////////////////////////////////////////////////////

		CONCRETELUABINDING_SOL(AHuman, Actor)

		g_pSolLuaState->set("UpperBodyState", g_pSolLuaState->create_table_with(
			"WEAPON_READY", AHuman::UpperBodyState::WEAPON_READY,
			"AIMING_SHARP", AHuman::UpperBodyState::AIMING_SHARP,
			"HOLSTERING_BACK", AHuman::UpperBodyState::HOLSTERING_BACK,
			"HOLSTERING_BELT", AHuman::UpperBodyState::DEHOLSTERING_BELT,
			"DEHOLSTERING_BACK", AHuman::UpperBodyState::DEHOLSTERING_BACK,
			"DEHOLSTERING_BELT", AHuman::UpperBodyState::DEHOLSTERING_BELT,
			"THROWING_PREP", AHuman::UpperBodyState::THROWING_PREP,
			"THROWING_RELEASE", AHuman::UpperBodyState::THROWING_RELEASE
		));
	
		g_pSolLuaState->set("MovementState", g_pSolLuaState->create_table_with(
			"NOMOVE", AHuman::MovementState::NOMOVE,
			"STAND", AHuman::MovementState::STAND,
			"WALK", AHuman::MovementState::WALK,
			"CROUCH", AHuman::MovementState::CROUCH,
			"CRAWL", AHuman::MovementState::CRAWL,
			"ARMCRAWL", AHuman::MovementState::ARMCRAWL,
			"CLIMB", AHuman::MovementState::CLIMB,
			"JUMP", AHuman::MovementState::JUMP,
			"DISLODGE", AHuman::MovementState::DISLODGE,
			"MOMENTSTATECOUNT", AHuman::MovementState::MOVEMENTSTATECOUNT
		));
			
		g_pSolLuaState->set("ProneState", g_pSolLuaState->create_table_with(
			"NOTPRONE", AHuman::ProneState::NOTPRONE,
			"GOPRONE", AHuman::ProneState::GOPRONE,
			"PRONE", AHuman::ProneState::PRONE,
			"PRONESTATECOUNT", AHuman::ProneState::PRONESTATECOUNT
		));

		g_pSolLuaState->set("Layer", g_pSolLuaState->create_table_with(
			"FGROUND", AHuman::FGROUND,
			"BGROUND", AHuman::BGROUND
		));

		g_pSolLuaState->set("DeviceHandlingState", g_pSolLuaState->create_table_with(
			"STILL", AHuman::DeviceHandlingState::STILL,
			"POINTING", AHuman::DeviceHandlingState::POINTING,
			"SCANNING", AHuman::DeviceHandlingState::SCANNING,
			"AIMING", AHuman::DeviceHandlingState::AIMING,
			"FIRING", AHuman::DeviceHandlingState::FIRING,
			"THROWING", AHuman::DeviceHandlingState::THROWING,
			"DIGGING", AHuman::DeviceHandlingState::DIGGING
		));

		g_pSolLuaState->set("SweepState", g_pSolLuaState->create_table_with(
			"NOSWEEP", AHuman::SweepState::NOSWEEP,
			"SWEEPINGUP", AHuman::SweepState::NOSWEEP,
			"SWEEPINGPAUSE", AHuman::SweepState::NOSWEEP,
			"SWEEPINGDOWN", AHuman::SweepState::NOSWEEP,
			"SWEEMDOWNPAUSE", AHuman::SweepState::NOSWEEP
		));

		g_pSolLuaState->set("DigState", g_pSolLuaState->create_table_with(
			"NOTDIGGING", AHuman::DigState::NOTDIGGING,
			"PREDIG", AHuman::DigState::PREDIG,
			"STARTDIG", AHuman::DigState::STARTDIG,
			"TUNNELING", AHuman::DigState::TUNNELING,
			"FINISHINGDIG", AHuman::DigState::FINISHINGDIG,
			"PAUSEDIGGER", AHuman::DigState::PAUSEDIGGER
		));

		g_pSolLuaState->set("JumpState", g_pSolLuaState->create_table_with(
			"NOTJUMPING", AHuman::JumpState::NOTJUMPING,
			"FORWARDJUMP", AHuman::JumpState::FORWARDJUMP,
			"PREJUMP", AHuman::JumpState::PREUPJUMP,
			"UPJUMP", AHuman::JumpState::UPJUMP,
			"APEXJUMP", AHuman::JumpState::APEXJUMP,
			"LANDJUMP", AHuman::JumpState::LANDJUMP
		));

		Bind["Head"] = sol::property(&AHuman::GetHead);
		Bind["FGArm"] = sol::property(&AHuman::GetFGArm);
		Bind["BGArm"] = sol::property(&AHuman::GetBGArm);
		Bind["FGLeg"] = sol::property(&AHuman::GetFGLeg);
		Bind["BGLeg"] = sol::property(&AHuman::GetBGLeg);
		Bind["Jetpack"] = sol::property(&AHuman::GetJetpack);
		Bind["JetTimeTotal"] = sol::property(&AHuman::GetJetTimeTotal, &AHuman::SetJetTimeTotal);
		Bind["JetTimeLeft"] = sol::property(&AHuman::GetJetTimeLeft, &AHuman::SetJetTimeLeft);
		Bind["EquipFirearm"] = &AHuman::EquipFirearm;
		Bind["EquipThrowable"] = &AHuman::EquipThrowable;
		Bind["EquipDiggingTool"] = &AHuman::EquipDiggingTool;
		Bind["EquipShield"] = &AHuman::EquipShield;
		Bind["EquipShieldInBGArm"] = &AHuman::EquipShieldInBGArm;
		Bind["EquipDeviceInGroup"] = &AHuman::EquipDeviceInGroup;
		Bind["EquipNamedDevice"] = &AHuman::EquipNamedDevice;
		Bind["EquipLoadedFirearmInGroup"] = &AHuman::EquipLoadedFirearmInGroup;
		Bind["UnequipBGArm"] = &AHuman::UnequipBGArm;
		Bind["EquippedItem"] = sol::property(&AHuman::GetEquippedItem);
		Bind["EquippedBGItem"] = sol::property(&AHuman::GetEquippedBGItem);
		Bind["FirearmIsReady"] = sol::property(&AHuman::FirearmIsReady);
		Bind["ThrowableIsReady"] = sol::property(&AHuman::ThrowableIsReady);
		Bind["FirearmIsEmpty"] = sol::property(&AHuman::FirearmIsEmpty);
		Bind["FirearmNeedsReload"] = sol::property(&AHuman::FirearmNeedsReload);
		Bind["FirearmIsSemiAuto"] = sol::property(&AHuman::FirearmIsSemiAuto);
		Bind["FirearmActivationDelay"] = sol::property(&AHuman::FirearmActivationDelay);
		Bind["ReloadFirearm"] = &AHuman::ReloadFirearm;
		Bind["IsWithinRange"] = &AHuman::IsWithinRange;
		Bind["Look"] = &AHuman::Look;
		Bind["LookForGold"] = &AHuman::LookForGold;
		Bind["LookForMOs"] = &AHuman::LookForMOs;
		Bind["IsOnScenePoint"] = &AHuman::IsOnScenePoint;
		Bind["LimbPathPushForce"] = sol::property(&AHuman::GetLimbPathPushForce, &AHuman::SetLimbPathPushForce);
		Bind["GetLimbPathSpeed"] = &AHuman::GetLimbPathSpeed;
		Bind["SetLimbPathSpeed"] = &AHuman::SetLimbPathSpeed;
	}

	{
		/*CONCRETELUABINDING(ACrab, Actor)
			.enum_("MovementState")
			[
				value("STAND", 0),
				value("WALK", 1),
				value("JUMP", 2),
				value("DISLODGE", 3),
				value("MOMENTSTATECOUNT", 4)
			]
			.enum_("Side")
			[
				value("LEFTSIDE", 0),
				value("RIGHTSIDE", 1),
				value("SIDECOUNT", 2)
			]
			.enum_("Layer")
			[
				value("FGROUND", 0),
				value("BGROUND", 1)
			]
			.enum_("DeviceHandlingState")
			[
				value("STILL", 0),
				value("POINTING", 1),
				value("SCANNING", 2),
				value("AIMING", 3),
				value("FIRING", 4),
				value("THROWING", 5),
				value("DIGGING", 6)
			]
			.enum_("SweepState")
			[
				value("NOSWEEP", 0),
				value("SWEEPINGUP", 1),
				value("SWEEPINGPAUSE", 2),
				value("SWEEPINGDOWN", 3),
				value("SWEEMDOWNPAUSE", 4)
			]
			.enum_("DigState")
			[
				value("NOTDIGGING", 0),
				value("PREDIG", 1),
				value("STARTDIG", 2),
				value("TUNNELING", 3),
				value("FINISHINGDIG", 4),
				value("PAUSEDIGGER", 5)
			]
			.enum_("JumpState")
			[
				value("NOTJUMPING", 0),
				value("FORWARDJUMP", 1),
				value("PREJUMP", 2),
				value("UPJUMP", 3),
				value("APEXJUMP", 4),
				value("LANDJUMP", 5)
			]
			.def(constructor<>())
			.property("Turret", &ACrab::GetTurret)
			.property("LFGLeg", &ACrab::GetLFGLeg)
			.property("LBGLeg", &ACrab::GetLBGLeg)
			.property("RFGLeg", &ACrab::GetRFGLeg)
			.property("RBGLeg", &ACrab::GetRBGLeg)
			.property("Jetpack", &ACrab::GetJetpack)
			.property("JetTimeTotal", &ACrab::GetJetTimeTotal, &ACrab::SetJetTimeTotal)
			.property("JetTimeLeft", &ACrab::GetJetTimeLeft)
			.property("EquippedItem", &ACrab::GetEquippedItem)
			.property("FirearmIsReady", &ACrab::FirearmIsReady)
			.property("FirearmIsEmpty", &ACrab::FirearmIsEmpty)
			.property("FirearmNeedsReload", &ACrab::FirearmNeedsReload)
			.property("FirearmIsSemiAuto", &ACrab::FirearmIsSemiAuto)
			.property("FirearmActivationDelay", &ACrab::FirearmActivationDelay)
			.def("ReloadFirearm", &ACrab::ReloadFirearm)
			.def("IsWithinRange", &ACrab::IsWithinRange)
			.def("Look", &ACrab::Look)
			.def("LookForMOs", &ACrab::LookForMOs)
			.def("IsOnScenePoint", &ACrab::IsOnScenePoint)
			.property("LimbPathPushForce", &ACrab::GetLimbPathPushForce, &ACrab::SetLimbPathPushForce)
			.def("GetLimbPathSpeed", &ACrab::GetLimbPathSpeed)
			.def("SetLimbPathSpeed", &ACrab::SetLimbPathSpeed),*/

		///////////////////////////////////////////////////////////////////////////

		CONCRETELUABINDING_SOL(ACrab, Actor)

		g_pSolLuaState->set("MovementState", g_pSolLuaState->create_table_with(
			"STAND", ACrab::MovementState::STAND,
			"WALK", ACrab::MovementState::WALK,
			"JUMP", ACrab::MovementState::JUMP,
			"DISLODGE", ACrab::MovementState::DISLODGE,
			"MOMENTSTATECOUNT", ACrab::MovementState::MOVEMENTSTATECOUNT
		));

		g_pSolLuaState->set("Side", g_pSolLuaState->create_table_with(
			"LEFTSIDE", ACrab::LEFTSIDE,
			"RIGHTSIDE", ACrab::RIGHTSIDE,
			"SIDECOUNT", ACrab::SIDECOUNT
		));

		g_pSolLuaState->set("Layer", g_pSolLuaState->create_table_with(
			"FGROUND", ACrab::FGROUND,
			"BGROUND", ACrab::BGROUND
		));

		g_pSolLuaState->set("DeviceHandlingState", g_pSolLuaState->create_table_with(
			"STILL", ACrab::DeviceHandlingState::STILL,
			"POINTING", ACrab::DeviceHandlingState::POINTING,
			"SCANNING", ACrab::DeviceHandlingState::SCANNING,
			"AIMING", ACrab::DeviceHandlingState::AIMING,
			"FIRING", ACrab::DeviceHandlingState::FIRING,
			"THROWING", ACrab::DeviceHandlingState::THROWING,
			"DIGGING", ACrab::DeviceHandlingState::DIGGING
		));
				
		g_pSolLuaState->set("SweepState", g_pSolLuaState->create_table_with(
			"NOSWEEP", ACrab::SweepState::NOSWEEP,
			"SWEEPINGUP", ACrab::SweepState::SWEEPINGUP,
			"SWEEPINGPAUSE", ACrab::SweepState::SWEEPUPPAUSE,
			"SWEEPINGDOWN", ACrab::SweepState::SWEEPINGDOWN,
			"SWEEMDOWNPAUSE", ACrab::SweepState::SWEEPDOWNPAUSE
		));

		g_pSolLuaState->set("DigState", g_pSolLuaState->create_table_with(
			"NOTDIGGING", ACrab::DigState::NOTDIGGING,
			"PREDIG", ACrab::DigState::PREDIG,
			"STARTDIG", ACrab::DigState::STARTDIG,
			"TUNNELING", ACrab::DigState::TUNNELING,
			"FINISHINGDIG", ACrab::DigState::FINISHINGDIG,
			"PAUSEDIGGER", ACrab::DigState::PAUSEDIGGER
		));

		g_pSolLuaState->set("JumpState", g_pSolLuaState->create_table_with(
			"NOTJUMPING", ACrab::JumpState::NOTJUMPING,
			"FORWARDJUMP", ACrab::JumpState::FORWARDJUMP,
			"PREJUMP", ACrab::JumpState::PREUPJUMP,
			"UPJUMP", ACrab::JumpState::UPJUMP,
			"APEXJUMP", ACrab::JumpState::APEXJUMP,
			"LANDJUMP", ACrab::JumpState::LANDJUMP
		));

		Bind["Turret"] = sol::property(&ACrab::GetTurret);
		Bind["LFGLeg"] = sol::property(&ACrab::GetLFGLeg);
		Bind["LBGLeg"] = sol::property(&ACrab::GetLBGLeg);
		Bind["RFGLeg"] = sol::property(&ACrab::GetRFGLeg);
		Bind["RBGLeg"] = sol::property(&ACrab::GetRBGLeg);
		Bind["Jetpack"] = sol::property(&ACrab::GetJetpack);
		Bind["JetTimeTotal"] = sol::property(&ACrab::GetJetTimeTotal, &ACrab::SetJetTimeTotal);
		Bind["JetTimeLeft"] = sol::property(&ACrab::GetJetTimeLeft);
		Bind["EquippedItem"] = sol::property(&ACrab::GetEquippedItem);
		Bind["FirearmIsReady"] = sol::property(&ACrab::FirearmIsReady);
		Bind["FirearmIsEmpty"] = sol::property(&ACrab::FirearmIsEmpty);
		Bind["FirearmNeedsReload"] = sol::property(&ACrab::FirearmNeedsReload);
		Bind["FirearmIsSemiAuto"] = sol::property(&ACrab::FirearmIsSemiAuto);
		Bind["FirearmActivationDelay"] = sol::property(&ACrab::FirearmActivationDelay);
		Bind["ReloadFirearm"] = &ACrab::ReloadFirearm;
		Bind["IsWithinRange"] = &ACrab::IsWithinRange;
		Bind["Look"] = &ACrab::Look;
		Bind["LookForMOs"] = &ACrab::LookForMOs;
		Bind["IsOnScenePoint"] = &ACrab::IsOnScenePoint;
		Bind["LimbPathPushForce"] = sol::property(&ACrab::GetLimbPathPushForce, &ACrab::SetLimbPathPushForce);
		Bind["GetLimbPathSpeed"] = &ACrab::GetLimbPathSpeed;
		Bind["SetLimbPathSpeed"] = &ACrab::SetLimbPathSpeed;
	}

	{
		/*ABSTRACTLUABINDING(ACraft, Actor)
			.enum_("HatchState")
			[
				value("CLOSED", 0),
				value("OPENING", 1),
				value("OPEN", 2),
				value("CLOSING", 3),
				value("HatchStateCount", 4)
			]
			.enum_("Side")
			[
				value("RIGHT", 0),
				value("LEFT", 1)
			]
			.enum_("CraftDeliverySequence")
			[
				value("FALL", 0),
				value("LAND", 1),
				value("STANDBY", 2),
				value("UNLOAD", 3),
				value("LAUNCH", 4),
				value("UNSTICK", 5)
			]
			.enum_("AltitudeMoveState")
			[
				value("HOVER", 0),
				value("DESCEND", 1),
				value("ASCEND", 2)
			]
			.def("OpenHatch", &ACraft::OpenHatch)
			.def("CloseHatch", &ACraft::CloseHatch)
			.property("HatchState", &ACraft::GetHatchState)
			.property("MaxPassengers", &ACraft::GetMaxPassengers)
			.property("DeliveryDelayMultiplier", &ACraft::GetDeliveryDelayMultiplier),*/

			///////////////////////////////////////////////////////////////////////////

			ABSTRACTLUABINDING_SOL(ACraft, Actor)

			g_pSolLuaState->set("HatchState", g_pSolLuaState->create_table_with(
				"CLOSED", ACraft::HatchState::CLOSED,
				"OPENING", ACraft::HatchState::OPENING,
				"OPEN", ACraft::HatchState::OPEN,
				"CLOSING", ACraft::HatchState::CLOSING,
				"HatchStateCount", ACraft::HatchState::HatchStateCount
			));

			g_pSolLuaState->set("Side", g_pSolLuaState->create_table_with(
				"RIGHT", ACraft::RIGHT,
				"LEFT", ACraft::LEFT
			));
				
			g_pSolLuaState->set("CraftDeliverySequence", g_pSolLuaState->create_table_with(
				"FALL", ACraft::CraftDeliverySequence::FALL,
				"LAND", ACraft::CraftDeliverySequence::LAND,
				"STANDBY", ACraft::CraftDeliverySequence::STANDBY,
				"UNLOAD", ACraft::CraftDeliverySequence::UNLOAD,
				"LAUNCH", ACraft::CraftDeliverySequence::LAUNCH,
				"UNSTICK", ACraft::CraftDeliverySequence::UNSTICK
			));

			g_pSolLuaState->set("AltitudeMoveState", g_pSolLuaState->create_table_with(
				"HOVER", ACraft::AltitudeMoveState::HOVER,
				"DESCEND", ACraft::AltitudeMoveState::DESCEND,
				"ASCEND", ACraft::AltitudeMoveState::ASCEND
			));
			
			Bind["OpenHatch"] = &ACraft::OpenHatch;
			Bind["CloseHatch"] = &ACraft::CloseHatch;
			Bind["HatchState"] = sol::property(&ACraft::GetHatchState);
			Bind["MaxPassengers"] = sol::property(&ACraft::GetMaxPassengers);
			Bind["DeliveryDelayMultiplier"] = sol::property(&ACraft::GetDeliveryDelayMultiplier);//*/
	}

	{
		/*CONCRETELUABINDING(ACDropShip, ACraft)
			.property("RightEngine", &ACDropShip::GetRThruster)
			.property("LeftEngine", &ACDropShip::GetLThruster)
			.property("RightThruster", &ACDropShip::GetURThruster)
			.property("LeftThruster", &ACDropShip::GetULThruster)
			.property("LeftHatch", &ACDropShip::GetLHatch)
			.property("RightHatch", &ACDropShip::GetRHatch)
			.property("MaxEngineAngle", &ACDropShip::GetMaxEngineAngle, &ACDropShip::SetMaxEngineAngle)
			.property("LateralControlSpeed", &ACDropShip::GetLateralControlSpeed, &ACDropShip::SetLateralControlSpeed)
			.property("LateralControl", &ACDropShip::GetLateralControl)
			.def("DetectObstacle", &ACDropShip::DetectObstacle)
			.def("GetAltitude", &ACDropShip::GetAltitude),//*/

		///////////////////////////////////////////////////////////////////////////

		CONCRETELUABINDING_SOL(ACDropShip, ACraft)

		Bind["RightEngine"] = sol::property(&ACDropShip::GetRThruster);
		Bind["LeftEngine"] = sol::property(&ACDropShip::GetLThruster);
		Bind["RightThruster"] = sol::property(&ACDropShip::GetURThruster);
		Bind["LeftThruster"] = sol::property(&ACDropShip::GetULThruster);
		Bind["LeftHatch"] = sol::property(&ACDropShip::GetLHatch);
		Bind["RightHatch"] = sol::property(&ACDropShip::GetRHatch);
		Bind["MaxEngineAngle"] = sol::property(&ACDropShip::GetMaxEngineAngle, &ACDropShip::SetMaxEngineAngle);
		Bind["LateralControlSpeed"] = sol::property(&ACDropShip::GetLateralControlSpeed, &ACDropShip::SetLateralControlSpeed);
		Bind["LateralControl"] = sol::property(&ACDropShip::GetLateralControl);
		Bind["DetectObstacle"] = &ACDropShip::DetectObstacle;
		Bind["GetAltitude"] = &ACDropShip::GetAltitude;//*/
	}

	{
		/*CONCRETELUABINDING(ACRocket, ACraft)
			.enum_("LandingGearState")
			[
				value("RAISED", 0),
				value("LOWERED", 1),
				value("LOWERING", 2),
				value("RAISING", 3),
				value("GearStateCount", 4)
			]
		.property("MainEngine", &ACRocket::GetMThruster)
			.property("LeftEngine", &ACRocket::GetLThruster)
			.property("RightEngine", &ACRocket::GetRThruster)
			.property("LeftThruster", &ACRocket::GetULThruster)
			.property("RightThruster", &ACRocket::GetURThruster)
			.property("GearState", &ACRocket::GetGearState),*/

		///////////////////////////////////////////////////////////////////////////

		CONCRETELUABINDING_SOL(ACRocket, ACraft)

		g_pSolLuaState->set("LandingGearState", g_pSolLuaState->create_table_with(
			"RAISED", ACRocket::LandingGearState::RAISED,
			"LOWERED", ACRocket::LandingGearState::LOWERED,
			"LOWERING", ACRocket::LandingGearState::LOWERING,
			"RAISING", ACRocket::LandingGearState::RAISING,
			"GearStateCount", ACRocket::LandingGearState::GearStateCount
		));

		Bind["MainEngine"] = sol::property(&ACRocket::GetMThruster);
		Bind["LeftEngine"] = sol::property(&ACRocket::GetLThruster);
		Bind["RightEngine"] = sol::property(&ACRocket::GetRThruster);
		Bind["LeftThruster"] = sol::property(&ACRocket::GetULThruster);
		Bind["RightThruster"] = sol::property(&ACRocket::GetURThruster);
		Bind["GearState"] = sol::property(&ACRocket::GetGearState);//*/
	}

	{
		/*CONCRETELUABINDING(HeldDevice, Attachable)
			.property("SupportPos", &HeldDevice::GetSupportPos)
			.property("MagazinePos", &HeldDevice::GetMagazinePos)
			.property("MuzzlePos", &HeldDevice::GetMuzzlePos)
			.property("MuzzleOffset", &HeldDevice::GetMuzzleOffset, &HeldDevice::SetMuzzleOffset)
			.property("StanceOffset", &HeldDevice::GetStanceOffset, &HeldDevice::SetStanceOffset)
			.property("SharpStanceOffset", &HeldDevice::GetSharpStanceOffset, &HeldDevice::SetSharpStanceOffset)
			.property("SharpLength", &HeldDevice::GetSharpLength, &HeldDevice::SetSharpLength)
			.def("IsWeapon", &HeldDevice::IsWeapon)
			.def("IsTool", &HeldDevice::IsTool)
			.def("IsShield", &HeldDevice::IsShield)
			.def("IsDualWieldable", &HeldDevice::IsDualWieldable)
			.def("SetDualWieldable", &HeldDevice::SetDualWieldable)
			.def("IsOneHanded", &HeldDevice::IsOneHanded)
			.def("SetOneHanded", &HeldDevice::SetOneHanded)
			.def("Activate", &HeldDevice::Activate)
			.def("Deactivate", &HeldDevice::Deactivate)
			.def("Reload", &HeldDevice::Reload)
			.def("IsActivated", &HeldDevice::IsActivated)
			.def("IsReloading", &HeldDevice::IsReloading)
			.def("DoneReloading", &HeldDevice::DoneReloading)
			.def("NeedsReloading", &HeldDevice::NeedsReloading)
			.def("IsFull", &HeldDevice::IsFull)
			.property("SharpLength", &HeldDevice::GetSharpLength, &HeldDevice::SetSharpLength)
			.property("SupportOffset", &HeldDevice::GetSupportOffset, &HeldDevice::SetSupportOffset)
			.def("SetSupported", &HeldDevice::SetSupported),*/

		///////////////////////////////////////////////////////////////////////////

		CONCRETELUABINDING_SOL(HeldDevice, Attachable)

		Bind["SupportPos"] = sol::property(&HeldDevice::GetSupportPos);
		Bind["MagazinePos"] = sol::property(&HeldDevice::GetMagazinePos);
		Bind["MuzzlePos"] = sol::property(&HeldDevice::GetMuzzlePos);
		Bind["MuzzleOffset"] = sol::property(&HeldDevice::GetMuzzleOffset, &HeldDevice::SetMuzzleOffset);
		Bind["StanceOffset"] = sol::property(&HeldDevice::GetStanceOffset, &HeldDevice::SetStanceOffset);
		Bind["SharpStanceOffset"] = sol::property(&HeldDevice::GetSharpStanceOffset, &HeldDevice::SetSharpStanceOffset);
		Bind["SharpLength"] = sol::property(&HeldDevice::GetSharpLength, &HeldDevice::SetSharpLength);
		Bind["IsWeapon"] = &HeldDevice::IsWeapon;
		Bind["IsTool"] = &HeldDevice::IsTool;
		Bind["IsShield"] = &HeldDevice::IsShield;
		Bind["IsDualWieldable"] = &HeldDevice::IsDualWieldable;
		Bind["SetDualWieldable"] = &HeldDevice::SetDualWieldable;
		Bind["IsOneHanded"] = &HeldDevice::IsOneHanded;
		Bind["SetOneHanded"] = &HeldDevice::SetOneHanded;
		Bind["Activate"] = &HeldDevice::Activate;
		Bind["Deactivate"] = &HeldDevice::Deactivate;
		Bind["Reload"] = &HeldDevice::Reload;
		Bind["IsActivated"] = &HeldDevice::IsActivated;
		Bind["IsReloading"] = &HeldDevice::IsReloading;
		Bind["DoneReloading"] = &HeldDevice::DoneReloading;
		Bind["NeedsReloading"] = &HeldDevice::NeedsReloading;
		Bind["IsFull"] = &HeldDevice::IsFull;
		Bind["SharpLength"] = sol::property(&HeldDevice::GetSharpLength, &HeldDevice::SetSharpLength);
		Bind["SupportOffset"] = sol::property(&HeldDevice::GetSupportOffset, &HeldDevice::SetSupportOffset);
		Bind["SetSupported"] = &HeldDevice::SetSupported;//*/
	}

	{
		/*CONCRETELUABINDING(Magazine, Attachable)
			.property("NextRound", &Magazine::GetNextRound)
			.property("RoundCount", &Magazine::GetRoundCount, &Magazine::SetRoundCount)
			.property("IsEmpty", &Magazine::IsEmpty)
			.property("IsFull", &Magazine::IsFull)
			.property("IsOverHalfFull", &Magazine::IsOverHalfFull)
			.property("Capacity", &Magazine::GetCapacity)
			.property("Discardable", &Magazine::IsDiscardable),*/

		///////////////////////////////////////////////////////////////////////////

		CONCRETELUABINDING_SOL(Magazine, Attachable)

		Bind["NextRound"] = sol::property(&Magazine::GetNextRound);
		Bind["RoundCount"] = sol::property(&Magazine::GetRoundCount, &Magazine::SetRoundCount);
		Bind["IsEmpty"] = sol::property(&Magazine::IsEmpty);
		Bind["IsFull"] = sol::property(&Magazine::IsFull);
		Bind["IsOverHalfFull"] = sol::property(&Magazine::IsOverHalfFull);
		Bind["Capacity"] = sol::property(&Magazine::GetCapacity);
		Bind["Discardable"] = sol::property(&Magazine::IsDiscardable);//*/
	}

	{
		/*CONCRETELUABINDING(Round, Entity)
			.property("NextParticle", &Round::GetNextParticle)
			.property("Shell", &Round::GetShell)
			.property("FireVel", &Round::GetFireVel)
			.property("ShellVel", &Round::GetShellVel)
			.property("Separation", &Round::GetSeparation)
			.property("ParticleCount", &Round::ParticleCount)
			.property("AILifeTime", &Round::GetAILifeTime)
			.property("AIFireVel", &Round::GetAIFireVel)
			.property("IsEmpty", &Round::IsEmpty),*/

		///////////////////////////////////////////////////////////////////////////

		CONCRETELUABINDING_SOL(Round, Entity);

		Bind["NextParticle"] = sol::property(&Round::GetNextParticle);
		Bind["Shell"] = sol::property(&Round::GetShell);
		Bind["FireVel"] = sol::property(&Round::GetFireVel);
		Bind["ShellVel"] = sol::property(&Round::GetShellVel);
		Bind["Separation"] = sol::property(&Round::GetSeparation);
		Bind["ParticleCount"] = sol::property(&Round::ParticleCount);
		Bind["AILifeTime"] = sol::property(&Round::GetAILifeTime);
		Bind["AIFireVel"] = sol::property(&Round::GetAIFireVel);
		Bind["IsEmpty"] = sol::property(&Round::IsEmpty);//*/
	}


	{
		/*CONCRETELUABINDING(HDFirearm, HeldDevice)
			.property("RateOfFire", &HDFirearm::GetRateOfFire, &HDFirearm::SetRateOfFire)
			.property("FullAuto", &HDFirearm::IsFullAuto, &HDFirearm::SetFullAuto)
			.property("RoundInMagCount", &HDFirearm::GetRoundInMagCount)
			.property("Magazine", &HDFirearm::GetMagazine)
			.property("ActivationDelay", &HDFirearm::GetActivationDelay, &HDFirearm::SetActivationDelay)
			.property("DeactivationDelay", &HDFirearm::GetDeactivationDelay, &HDFirearm::SetDeactivationDelay)
			.property("ReloadTime", &HDFirearm::GetReloadTime, &HDFirearm::SetReloadTime)
			.property("ShakeRange", &HDFirearm::GetShakeRange, &HDFirearm::SetShakeRange)
			.property("SharpShakeRange", &HDFirearm::GetSharpShakeRange, &HDFirearm::SetSharpShakeRange)
			.property("NoSupportFactor", &HDFirearm::GetNoSupportFactor, &HDFirearm::SetNoSupportFactor)
			.property("ParticleSpreadRange", &HDFirearm::GetParticleSpreadRange, &HDFirearm::SetParticleSpreadRange)
			.property("FiredOnce", &HDFirearm::FiredOnce)
			.property("FiredFrame", &HDFirearm::FiredFrame)
			.property("RoundsFired", &HDFirearm::RoundsFired)
			.def("GetAIFireVel", &HDFirearm::GetAIFireVel)
			.def("GetAIBulletLifeTime", &HDFirearm::GetAIBulletLifeTime)
			.def("GetBulletAccScalar", &HDFirearm::GetBulletAccScalar)
			.def("GetAIBlastRadius", &HDFirearm::GetAIBlastRadius)
			.def("GetAIPenetration", &HDFirearm::GetAIPenetration)
			.def("CompareTrajectories", &HDFirearm::CompareTrajectories)
			.def("SetNextMagazineName", &HDFirearm::SetNextMagazineName)
			.property("IsAnimatedManually", &HDFirearm::IsAnimatedManually, &HDFirearm::SetAnimatedManually)
			.property("RecoilTransmission", &HDFirearm::GetRecoilTransmission, &HDFirearm::SetRecoilTransmission),*/

		///////////////////////////////////////////////////////////////////////////

		CONCRETELUABINDING_SOL(HDFirearm, HeldDevice);

		Bind["RateOfFire"] = sol::property(&HDFirearm::GetRateOfFire, &HDFirearm::SetRateOfFire);
		Bind["FullAuto"] = sol::property(&HDFirearm::IsFullAuto, &HDFirearm::SetFullAuto);
		Bind["RoundInMagCount"] = sol::property(&HDFirearm::GetRoundInMagCount);
		Bind["Magazine"] = sol::property(&HDFirearm::GetMagazine);
		Bind["ActivationDelay"] = sol::property(&HDFirearm::GetActivationDelay, &HDFirearm::SetActivationDelay);
		Bind["DeactivationDelay"] = sol::property(&HDFirearm::GetDeactivationDelay, &HDFirearm::SetDeactivationDelay);
		Bind["ReloadTime"] = sol::property(&HDFirearm::GetReloadTime, &HDFirearm::SetReloadTime);
		Bind["ShakeRange"] = sol::property(&HDFirearm::GetShakeRange, &HDFirearm::SetShakeRange);
		Bind["SharpShakeRange"] = sol::property(&HDFirearm::GetSharpShakeRange, &HDFirearm::SetSharpShakeRange);
		Bind["NoSupportFactor"] = sol::property(&HDFirearm::GetNoSupportFactor, &HDFirearm::SetNoSupportFactor);
		Bind["ParticleSpreadRange"] = sol::property(&HDFirearm::GetParticleSpreadRange, &HDFirearm::SetParticleSpreadRange);
		Bind["FiredOnce"] = sol::property(&HDFirearm::FiredOnce);
		Bind["FiredFrame"] = sol::property(&HDFirearm::FiredFrame);
		Bind["RoundsFired"] = sol::property(&HDFirearm::RoundsFired);
		Bind["GetAIFireVel"] = &HDFirearm::GetAIFireVel;
		Bind["GetAIBulletLifeTime"] = &HDFirearm::GetAIBulletLifeTime;
		Bind["GetBulletAccScalar"] = &HDFirearm::GetBulletAccScalar;
		Bind["GetAIBlastRadius"] = &HDFirearm::GetAIBlastRadius;
		Bind["GetAIPenetration"] = &HDFirearm::GetAIPenetration;
		Bind["CompareTrajectories"] = &HDFirearm::CompareTrajectories;
		Bind["SetNextMagazineName"] = &HDFirearm::SetNextMagazineName;
		Bind["IsAnimatedManually"] = sol::property(&HDFirearm::IsAnimatedManually, &HDFirearm::SetAnimatedManually);
		Bind["RecoilTransmission"] = sol::property(&HDFirearm::GetRecoilTransmission, &HDFirearm::SetRecoilTransmission);//*/
	}

	{
		/*CONCRETELUABINDING(ThrownDevice, HeldDevice)
			.property("MinThrowVel", &ThrownDevice::GetMinThrowVel, &ThrownDevice::SetMinThrowVel)
			.property("MaxThrowVel", &ThrownDevice::GetMaxThrowVel, &ThrownDevice::SetMaxThrowVel),*/

		///////////////////////////////////////////////////////////////////////////

		CONCRETELUABINDING_SOL(ThrownDevice, HeldDevice);

		Bind["MinThrowVel"] = sol::property(&ThrownDevice::GetMinThrowVel, &ThrownDevice::SetMinThrowVel);
		Bind["MaxThrowVel"] = sol::property(&ThrownDevice::GetMaxThrowVel, &ThrownDevice::SetMaxThrowVel);//*/
	}

	{
		CONCRETELUABINDING_SOL(TDExplosive, ThrownDevice);//*/
	}

	{
	/*
		class_<Controller>("Controller")
			.enum_("ControlState")
			[
				value("PRIMARY_ACTION", 0),
				value("SECONDARY_ACTION", 1),
				value("MOVE_IDLE", 2),
				value("MOVE_RIGHT", 3),
				value("MOVE_LEFT", 4),
				value("MOVE_UP", 5),
				value("MOVE_DOWN", 6),
				value("MOVE_FAST", 7),
				value("BODY_JUMPSTART", 8),
				value("BODY_JUMP", 9),
				value("BODY_CROUCH", 10),
				value("AIM_UP", 11),
				value("AIM_DOWN", 12),
				value("AIM_SHARP", 13),
				value("WEAPON_FIRE", 14),
				value("WEAPON_RELOAD", 15),
				value("PIE_MENU_ACTIVE", 16),
				value("WEAPON_CHANGE_NEXT", 17),
				value("WEAPON_CHANGE_PREV", 18),
				value("WEAPON_PICKUP", 19),
				value("WEAPON_DROP", 20),
				value("ACTOR_NEXT", 21),
				value("ACTOR_PREV", 22),
				value("ACTOR_BRAIN", 23),
				value("ACTOR_NEXT_PREP", 24),
				value("ACTOR_PREV_PREP", 25),
				value("HOLD_RIGHT", 26),
				value("HOLD_LEFT", 27),
				value("HOLD_UP", 28),
				value("HOLD_DOWN", 29),
				value("PRESS_PRIMARY", 30),
				value("PRESS_SECONDARY", 31),
				value("PRESS_RIGHT", 32),
				value("PRESS_LEFT", 33),
				value("PRESS_UP", 34),
				value("PRESS_DOWN", 35),
				value("RELEASE_PRIMARY", 36),
				value("RELEASE_SECONDARY", 37),
				value("PRESS_FACEBUTTON", 38),
				value("SCROLL_UP", 39),
				value("SCROLL_DOWN", 40),
				value("DEBUG_ONE", 41),
				value("CONTROLSTATECOUNT", 42)
			]
			.enum_("InputMode")
			[
				value("CIM_DISABLED", 0),
				value("CIM_PLAYER", 1),
				value("CIM_AI", 2),
				value("CIM_NETWORK", 3),
				value("CIM_INPUTMODECOUNT", 4)
			]
			.def(luabind::constructor<>())
			.property("InputMode", &Controller::GetInputMode, &Controller::SetInputMode)
			.def("IsPlayerControlled", &Controller::IsPlayerControlled)
			.property("ControlledActor", &Controller::GetControlledActor, &Controller::SetControlledActor)
			.property("Team", &Controller::GetTeam, &Controller::SetTeam)
			.property("AnalogMove", &Controller::GetAnalogMove, &Controller::SetAnalogMove)
			.property("AnalogAim", &Controller::GetAnalogAim, &Controller::SetAnalogAim)
			.property("AnalogCursor", &Controller::GetAnalogCursor)
			.def("RelativeCursorMovement", &Controller::RelativeCursorMovement)
			.property("Player", &Controller::GetPlayer, &Controller::SetPlayer)
			.def("IsMouseControlled", &Controller::IsMouseControlled)
			.property("MouseMovement", &Controller::GetMouseMovement)
			.property("Disabled", &Controller::IsDisabled, &Controller::SetDisabled)
			.def("SetState", &Controller::SetState)
			.def("IsState", &Controller::IsState),
	*/

		///////////////////////////////////////////////////////////////////////////

		sol::usertype<Controller> Bind = g_pSolLuaState->new_usertype<Controller>("Controller", sol::no_constructor);

		g_pSolLuaState->set("ControlState", g_pSolLuaState->create_table_with(
			"PRIMARY_ACTION", ControlState::PRIMARY_ACTION,
			"SECONDARY_ACTION", ControlState::SECONDARY_ACTION,
			"MOVE_IDLE", ControlState::MOVE_IDLE,
			"MOVE_RIGHT", ControlState::MOVE_RIGHT,
			"MOVE_LEFT", ControlState::MOVE_LEFT,
			"MOVE_UP", ControlState::MOVE_UP,
			"MOVE_DOWN", ControlState::MOVE_DOWN,
			"MOVE_FAST", ControlState::MOVE_FAST,
			"BODY_JUMPSTART", ControlState::BODY_JUMPSTART,
			"BODY_JUMP", ControlState::BODY_JUMP,
			"BODY_CROUCH", ControlState::BODY_CROUCH,
			"AIM_UP", ControlState::AIM_UP,
			"AIM_DOWN", ControlState::AIM_DOWN,
			"AIM_SHARP", ControlState::AIM_SHARP,
			"WEAPON_FIRE", ControlState::WEAPON_FIRE,
			"WEAPON_RELOAD", ControlState::WEAPON_RELOAD,
			"PIE_MENU_ACTIVE", ControlState::PIE_MENU_ACTIVE,
			"WEAPON_CHANGE_NEXT", ControlState::WEAPON_CHANGE_NEXT,
			"WEAPON_CHANGE_PREV", ControlState::WEAPON_CHANGE_PREV,
			"WEAPON_PICKUP", ControlState::WEAPON_PICKUP,
			"WEAPON_DROP", ControlState::WEAPON_DROP,
			"ACTOR_NEXT", ControlState::ACTOR_NEXT,
			"ACTOR_PREV", ControlState::ACTOR_PREV,
			"ACTOR_BRAIN", ControlState::ACTOR_BRAIN,
			"ACTOR_NEXT_PREP", ControlState::ACTOR_NEXT_PREP,
			"ACTOR_PREV_PREP", ControlState::ACTOR_PREV_PREP,
			"HOLD_RIGHT", ControlState::HOLD_RIGHT,
			"HOLD_LEFT", ControlState::HOLD_LEFT,
			"HOLD_UP", ControlState::HOLD_UP,
			"HOLD_DOWN", ControlState::HOLD_DOWN,
			"PRESS_PRIMARY", ControlState::PRESS_PRIMARY,
			"PRESS_SECONDARY", ControlState::PRESS_SECONDARY,
			"PRESS_RIGHT", ControlState::PRESS_RIGHT,
			"PRESS_LEFT", ControlState::PRESS_LEFT,
			"PRESS_UP", ControlState::PRESS_UP,
			"PRESS_DOWN", ControlState::PRESS_DOWN,
			"RELEASE_PRIMARY", ControlState::RELEASE_PRIMARY,
			"RELEASE_SECONDARY", ControlState::RELEASE_SECONDARY,
			"PRESS_FACEBUTTON", ControlState::PRESS_FACEBUTTON,
			"SCROLL_UP", ControlState::SCROLL_UP,
			"SCROLL_DOWN", ControlState::SCROLL_DOWN,
			"DEBUG_ONE", ControlState::DEBUG_ONE,
			"CONTROLSTATECOUNT", ControlState::CONTROLSTATECOUNT
		));

		g_pSolLuaState->set("InputMode", g_pSolLuaState->create_table_with(
			"CIM_DISABLED", Controller::InputMode::CIM_DISABLED,
			"CIM_PLAYER", Controller::InputMode::CIM_PLAYER,
			"CIM_AI", Controller::InputMode::CIM_AI,
			"CIM_NETWORK", Controller::InputMode::CIM_NETWORK,
			"CIM_INPUTMODECOUNT", Controller::InputMode::CIM_INPUTMODECOUNT
		));

		Bind["InputMode"] = sol::property(&Controller::GetInputMode, &Controller::SetInputMode);
		Bind["IsPlayerControlled"] = &Controller::IsPlayerControlled;
		Bind["ControlledActor"] = sol::property(&Controller::GetControlledActor, &Controller::SetControlledActor);
		Bind["Team"] = sol::property(&Controller::GetTeam, &Controller::SetTeam);
		Bind["AnalogMove"] = sol::property(&Controller::GetAnalogMove, &Controller::SetAnalogMove);
		Bind["AnalogAim"] = sol::property(&Controller::GetAnalogAim, &Controller::SetAnalogAim);
		Bind["AnalogCursor"] = sol::property(&Controller::GetAnalogCursor);
		Bind["RelativeCursorMovement"] = &Controller::RelativeCursorMovement;
		Bind["Player"] = sol::property(&Controller::GetPlayer, &Controller::SetPlayer);
		Bind["IsMouseControlled"] = &Controller::IsMouseControlled;
		Bind["MouseMovement"] = sol::property(&Controller::GetMouseMovement);
		Bind["Disabled"] = sol::property(&Controller::IsDisabled, &Controller::SetDisabled);
		Bind["SetState"] = &Controller::SetState;
		Bind["IsState"] = &Controller::IsState;//*/
	}

	{
		/*class_<Timer>("Timer")
			.def(luabind::constructor<>())
			.def("Reset", &Timer::Reset)
			.property("StartRealTimeMS", &Timer::GetStartRealTimeMS, &Timer::SetStartRealTimeMS)
			.property("ElapsedRealTimeS", &Timer::GetElapsedRealTimeS, &Timer::SetElapsedRealTimeS)
			.property("ElapsedRealTimeMS", &Timer::GetElapsedRealTimeMS, &Timer::SetElapsedRealTimeMS)
			.def("SetRealTimeLimitMS", &Timer::SetRealTimeLimitMS)
			.def("SetRealTimeLimitS", &Timer::SetRealTimeLimitS)
			.def("IsPastRealTimeLimit", &Timer::IsPastRealTimeLimit)
			.def("LeftTillRealTimeLimitMS", &Timer::LeftTillRealTimeLimitMS)
			.def("LeftTillRealTimeLimitS", &Timer::LeftTillRealTimeLimitS)
			.def("LeftTillRealMS", &Timer::LeftTillRealMS)
			.def("IsPastRealMS", &Timer::IsPastRealMS)
			.def("AlternateReal", &Timer::AlternateReal)
			.property("StartSimTimeMS", &Timer::GetStartSimTimeMS, &Timer::SetStartSimTimeMS)
			.property("ElapsedSimTimeS", &Timer::GetElapsedSimTimeS, &Timer::SetElapsedSimTimeS)
			.property("ElapsedSimTimeMS", &Timer::GetElapsedSimTimeMS, &Timer::SetElapsedSimTimeMS)
			.def("SetSimTimeLimitMS", &Timer::SetSimTimeLimitMS)
			.def("SetSimTimeLimitS", &Timer::SetSimTimeLimitS)
			.def("IsPastSimTimeLimit", &Timer::IsPastSimTimeLimit)
			.def("LeftTillSimTimeLimitMS", &Timer::LeftTillSimTimeLimitMS)
			.def("LeftTillSimTimeLimitS", &Timer::LeftTillSimTimeLimitS)
			.def("LeftTillSimMS", &Timer::LeftTillSimMS)
			.def("IsPastSimMS", &Timer::IsPastSimMS)
			.def("AlternateSim", &Timer::AlternateSim),*/

		///////////////////////////////////////////////////////////////////////////

		sol::usertype<Timer> Bind = g_pSolLuaState->new_usertype<Timer>("Timer", sol::constructors<Timer()>());

		Bind["Reset"] = &Timer::Reset;
		Bind["StartRealTimeMS"] = sol::property(&Timer::GetStartRealTimeMS, &Timer::SetStartRealTimeMS);
		Bind["ElapsedRealTimeS"] = sol::property(&Timer::GetElapsedRealTimeS, &Timer::SetElapsedRealTimeS);
		Bind["ElapsedRealTimeMS"] = sol::property(&Timer::GetElapsedRealTimeMS, &Timer::SetElapsedRealTimeMS);
		Bind["SetRealTimeLimitMS"] = &Timer::SetRealTimeLimitMS;
		Bind["SetRealTimeLimitS"] = &Timer::SetRealTimeLimitS;
		Bind["IsPastRealTimeLimit"] = &Timer::IsPastRealTimeLimit;
		Bind["LeftTillRealTimeLimitMS"] = &Timer::LeftTillRealTimeLimitMS;
		Bind["LeftTillRealTimeLimitS"] = &Timer::LeftTillRealTimeLimitS;
		Bind["LeftTillRealMS"] = &Timer::LeftTillRealMS;
		Bind["IsPastRealMS"] = &Timer::IsPastRealMS;
		Bind["AlternateReal"] = &Timer::AlternateReal;
		Bind["StartSimTimeMS"] = sol::property(&Timer::GetStartSimTimeMS, &Timer::SetStartSimTimeMS);
		Bind["ElapsedSimTimeS"] = sol::property(&Timer::GetElapsedSimTimeS, &Timer::SetElapsedSimTimeS);
		Bind["ElapsedSimTimeMS"] = sol::property(&Timer::GetElapsedSimTimeMS, &Timer::SetElapsedSimTimeMS);
		Bind["SetSimTimeLimitMS"] = &Timer::SetSimTimeLimitMS;
		Bind["SetSimTimeLimitS"] = &Timer::SetSimTimeLimitS;
		Bind["IsPastSimTimeLimit"] = &Timer::IsPastSimTimeLimit;
		Bind["LeftTillSimTimeLimitMS"] = &Timer::LeftTillSimTimeLimitMS;
		Bind["LeftTillSimTimeLimitS"] = &Timer::LeftTillSimTimeLimitS;
		Bind["LeftTillSimMS"] = &Timer::LeftTillSimMS;
		Bind["IsPastSimMS"] = &Timer::IsPastSimMS;
		Bind["AlternateSim"] = &Timer::AlternateSim;//*/

	}

	{
	
		/*        class_<TimerMan>("TimerManager")
            .property("TicksPerSecond", &TimerMan::GetTicksPerSecondInLua)
            .property("TimeScale", &TimerMan::GetTimeScale, &TimerMan::SetTimeScale)
            .def("EnableAveraging", &TimerMan::EnableAveraging)
            .property("RealToSimCap", &TimerMan::GetRealToSimCap, &TimerMan::SetRealToSimCap)
            .property("DeltaTimeTicks", &TimerMan::GetDeltaTimeTicks, &TimerMan::SetDeltaTimeTicks)
            .property("DeltaTimeSecs", &TimerMan::GetDeltaTimeSecs, &TimerMan::SetDeltaTimeSecs)
            .property("DeltaTimeMS", &TimerMan::GetDeltaTimeMS)
            .def("PauseSim", &TimerMan::PauseSim)
            .property("OneSimUpdatePerFrame", &TimerMan::IsOneSimUpdatePerFrame, &TimerMan::SetOneSimUpdatePerFrame)
            .def("TimeForSimUpdate", &TimerMan::TimeForSimUpdate)
            .def("DrawnSimUpdate", &TimerMan::DrawnSimUpdate),
		*/

		///////////////////////////////////////////////////////////////////////////

		sol::usertype<TimerMan> Bind = g_pSolLuaState->new_usertype<TimerMan>("Timer", sol::no_constructor);
		
		Bind["TicksPerSecond"] = sol::property(&TimerMan::GetTicksPerSecondInLua);
		Bind["TimeScale"] = sol::property(&TimerMan::GetTimeScale, &TimerMan::SetTimeScale);
		Bind["EnableAveraging"] = &TimerMan::EnableAveraging;
		Bind["RealToSimCap"] = sol::property(&TimerMan::GetRealToSimCap, &TimerMan::SetRealToSimCap);
		Bind["DeltaTimeTicks"] = sol::property(&TimerMan::GetDeltaTimeTicks, &TimerMan::SetDeltaTimeTicks);
		Bind["DeltaTimeSecs"] = sol::property(&TimerMan::GetDeltaTimeSecs, &TimerMan::SetDeltaTimeSecs);
		Bind["DeltaTimeMS"] = sol::property(&TimerMan::GetDeltaTimeMS);
		Bind["PauseSim"] = &TimerMan::PauseSim;
		Bind["OneSimUpdatePerFrame"] = sol::property(&TimerMan::IsOneSimUpdatePerFrame, &TimerMan::SetOneSimUpdatePerFrame);
		Bind["TimeForSimUpdate"] = &TimerMan::TimeForSimUpdate;
		Bind["DrawnSimUpdate"] = &TimerMan::DrawnSimUpdate;//*/
	}

	{
		/*
		class_<FrameMan>("FrameManager")
			.def("ResetSplitScreens", &FrameMan::ResetSplitScreens)
			.property("PPM", &FrameMan::GetPPM, &FrameMan::SetPPM)
			.property("MPP", &FrameMan::GetMPP)
			.property("PPL", &FrameMan::GetPPL)
			.property("LPP", &FrameMan::GetLPP)
			.property("ResX", &FrameMan::GetResX)
			.property("ResY", &FrameMan::GetResY)
			.property("ResBPP", &FrameMan::GetBPP)
			.property("HSplit", &FrameMan::GetHSplit, &FrameMan::SetHSplit)
			.property("VSplit", &FrameMan::GetVSplit, &FrameMan::SetVSplit)
			.property("PlayerScreenWidth", &FrameMan::GetPlayerScreenWidth)
			.property("PlayerScreenHeight", &FrameMan::GetPlayerScreenHeight)
			.def("GetPlayerFrameBufferWidth", &FrameMan::GetPlayerFrameBufferWidth)
			.def("GetPlayerFrameBufferHeight", &FrameMan::GetPlayerFrameBufferHeight)
			.def("SetScreenText", &FrameMan::SetScreenText)
			.def("ClearScreenText", &FrameMan::ClearScreenText)
			.def("IsFullscreen", &FrameMan::IsFullscreen)
			.property("PostProcessing", &FrameMan::IsPostProcessing, &FrameMan::EnablePostProcessing)
			.property("PostPixelGlow", &FrameMan::IsPixelGlowEnabled, &FrameMan::EnablePixelGlow)
			.def("LoadPalette", &FrameMan::LoadPalette)
			.def("FadeInPalette", &FrameMan::FadeInPalette)
			.def("FadeOutPalette", &FrameMan::FadeOutPalette)
			.def("SaveScreenToBMP", &FrameMan::SaveScreenToBMP)
			.def("SaveBitmapToBMP", &FrameMan::SaveBitmapToBMP)
			.def("ResetFrameTimer", &FrameMan::ResetFrameTimer)
			.def("ResetRTE", &FrameMan::ResetRTE)
			.def("IsResettingRTE", &FrameMan::IsResettingRTE)
			.def("ToggleFullscreen", &FrameMan::ToggleFullscreen)
			.def("ClearBackBuffer8", &FrameMan::ClearBackBuffer8)
			.def("ClearBackBuffer32", &FrameMan::ClearBackBuffer32)
			.def("ShowPerformanceStats", &FrameMan::ShowPerformanceStats)
			.def("FlashScreen", &FrameMan::FlashScreen)
			.def("DrawCirclePrimitive", (void (FrameMan::*)(Vector pos, int radius, int color))&FrameMan::DrawCirclePrimitive)
			.def("DrawCircleFillPrimitive", (void (FrameMan::*)(Vector pos, int radius, int color))&FrameMan::DrawCircleFillPrimitive)
			.def("DrawLinePrimitive", (void (FrameMan::*)(Vector start, Vector end, int color))&FrameMan::DrawLinePrimitive)
			.def("DrawTextPrimitive", (void (FrameMan::*)(Vector start, std::string text, bool isSmall, int alignment))&FrameMan::DrawTextPrimitive)
			.def("DrawBitmapPrimitive", (void (FrameMan::*)(Vector start, Entity * pEntity, float rotAngle, int frame))&FrameMan::DrawBitmapPrimitive)
			.def("DrawBoxPrimitive", (void (FrameMan::*)(Vector start, Vector end, int color))&FrameMan::DrawBoxPrimitive)
			.def("DrawBoxFillPrimitive", (void (FrameMan::*)(Vector start, Vector end, int color))&FrameMan::DrawBoxFillPrimitive)
			.def("DrawCirclePrimitive", (void (FrameMan::*)(int player, Vector pos, int radius, int color))&FrameMan::DrawCirclePrimitive)
			.def("DrawCircleFillPrimitive", (void (FrameMan::*)(int player, Vector pos, int radius, int color))&FrameMan::DrawCircleFillPrimitive)
			.def("DrawLinePrimitive", (void (FrameMan::*)(int player, Vector start, Vector end, int color))&FrameMan::DrawLinePrimitive)
			.def("DrawTextPrimitive", (void (FrameMan::*)(int player, Vector start, std::string text, bool isSmall, int alignment))&FrameMan::DrawTextPrimitive)
			.def("DrawBitmapPrimitive", (void (FrameMan::*)(int player, Vector start, Entity * pEntity, float rotAngle, int frame))&FrameMan::DrawBitmapPrimitive)
			.def("DrawBoxPrimitive", (void (FrameMan::*)(int player, Vector start, Vector end, int color))&FrameMan::DrawBoxPrimitive)
			.def("DrawBoxFillPrimitive", (void (FrameMan::*)(int player, Vector start, Vector end, int color))&FrameMan::DrawBoxFillPrimitive)
			.def("CalculateTextHeight", &FrameMan::CalculateTextHeight)
			.def("CalculateTextWidth", &FrameMan::CalculateTextWidth),
	*/

		///////////////////////////////////////////////////////////////////////////

		sol::usertype<FrameMan> Bind = g_pSolLuaState->new_usertype<FrameMan>("FrameManager", sol::no_constructor);

		Bind["ResetSplitScreens"] = &FrameMan::ResetSplitScreens;
		Bind["PPM"] = sol::property(&FrameMan::GetPPM, &FrameMan::SetPPM);
		Bind["MPP"] = sol::property(&FrameMan::GetMPP);
		Bind["PPL"] = sol::property(&FrameMan::GetPPL);
		Bind["LPP"] = sol::property(&FrameMan::GetLPP);
		Bind["ResX"] = sol::property(&FrameMan::GetResX);
		Bind["ResY"] = sol::property(&FrameMan::GetResY);
		Bind["ResBPP"] = sol::property(&FrameMan::GetBPP);
		Bind["HSplit"] = sol::property(&FrameMan::GetHSplit, &FrameMan::SetHSplit);
		Bind["VSplit"] = sol::property(&FrameMan::GetVSplit, &FrameMan::SetVSplit);
		Bind["PlayerScreenWidth"] = sol::property(&FrameMan::GetPlayerScreenWidth);
		Bind["PlayerScreenHeight"] = sol::property(&FrameMan::GetPlayerScreenHeight);
		Bind["GetPlayerFrameBufferWidth"] = &FrameMan::GetPlayerFrameBufferWidth;
		Bind["GetPlayerFrameBufferHeight"] = &FrameMan::GetPlayerFrameBufferHeight;
		Bind["SetScreenText"] = &FrameMan::SetScreenText;
		Bind["ClearScreenText"] = &FrameMan::ClearScreenText;
		Bind["IsFullscreen"] = &FrameMan::IsFullscreen;
		Bind["PostProcessing"] = sol::property(&FrameMan::IsPostProcessing, &FrameMan::EnablePostProcessing);
		Bind["PostPixelGlow"] = sol::property(&FrameMan::IsPixelGlowEnabled, &FrameMan::EnablePixelGlow);
		Bind["LoadPalette"] = &FrameMan::LoadPalette;
		Bind["FadeInPalette"] = &FrameMan::FadeInPalette;
		Bind["FadeOutPalette"] = &FrameMan::FadeOutPalette;
		Bind["SaveScreenToBMP"] = &FrameMan::SaveScreenToBMP;
		Bind["SaveBitmapToBMP"] = &FrameMan::SaveBitmapToBMP;
		Bind["ResetFrameTimer"] = &FrameMan::ResetFrameTimer;
		Bind["ResetRTE"] = &FrameMan::ResetRTE;
		Bind["IsResettingRTE"] = &FrameMan::IsResettingRTE;
		Bind["ToggleFullscreen"] = &FrameMan::ToggleFullscreen;
		Bind["ClearBackBuffer8"] = &FrameMan::ClearBackBuffer8;
		Bind["ClearBackBuffer32"] = &FrameMan::ClearBackBuffer32;
		Bind["ShowPerformanceStats"] = &FrameMan::ShowPerformanceStats;
		Bind["FlashScreen"] = &FrameMan::FlashScreen;
		Bind["DrawCirclePrimitive"] = (void (FrameMan::*)(Vector pos, int radius, int color)) & FrameMan::DrawCirclePrimitive;
		Bind["DrawCircleFillPrimitive"] = (void (FrameMan::*)(Vector pos, int radius, int color)) & FrameMan::DrawCircleFillPrimitive;
		Bind["DrawLinePrimitive"] = (void (FrameMan::*)(Vector start, Vector end, int color)) & FrameMan::DrawLinePrimitive;
		Bind["DrawTextPrimitive"] = (void (FrameMan::*)(Vector start, std::string text, bool isSmall, int alignment)) & FrameMan::DrawTextPrimitive;
		Bind["DrawBitmapPrimitive"] = (void (FrameMan::*)(Vector start, Entity * pEntity, float rotAngle, int frame)) & FrameMan::DrawBitmapPrimitive;
		Bind["DrawBoxPrimitive"] = (void (FrameMan::*)(Vector start, Vector end, int color)) & FrameMan::DrawBoxPrimitive;
		Bind["DrawBoxFillPrimitive"] = (void (FrameMan::*)(Vector start, Vector end, int color)) & FrameMan::DrawBoxFillPrimitive;
		Bind["DrawCirclePrimitive"] = (void (FrameMan::*)(int player, Vector pos, int radius, int color)) & FrameMan::DrawCirclePrimitive;
		Bind["DrawCircleFillPrimitive"] = (void (FrameMan::*)(int player, Vector pos, int radius, int color)) & FrameMan::DrawCircleFillPrimitive;
		Bind["DrawLinePrimitive"] = (void (FrameMan::*)(int player, Vector start, Vector end, int color)) & FrameMan::DrawLinePrimitive;
		Bind["DrawTextPrimitive"] = (void (FrameMan::*)(int player, Vector start, std::string text, bool isSmall, int alignment)) & FrameMan::DrawTextPrimitive;
		Bind["DrawBitmapPrimitive"] = (void (FrameMan::*)(int player, Vector start, Entity * pEntity, float rotAngle, int frame)) & FrameMan::DrawBitmapPrimitive;
		Bind["DrawBoxPrimitive"] = (void (FrameMan::*)(int player, Vector start, Vector end, int color)) & FrameMan::DrawBoxPrimitive;
		Bind["DrawBoxFillPrimitive"] = (void (FrameMan::*)(int player, Vector start, Vector end, int color)) & FrameMan::DrawBoxFillPrimitive;
		Bind["CalculateTextHeight"] = &FrameMan::CalculateTextHeight;
		Bind["CalculateTextWidth"] = &FrameMan::CalculateTextWidth;//*/
	}

	{
	/*
		class_<PresetMan>("PresetManager")
			.def("LoadDataModule", (bool (PresetMan::*)(string))&PresetMan::LoadDataModule)
			.def("GetDataModule", &PresetMan::GetDataModule)
			.def("GetModuleID", &PresetMan::GetModuleID)
			.def("GetModuleIDFromPath", &PresetMan::GetModuleIDFromPath)
			.def("GetTotalModuleCount", &PresetMan::GetTotalModuleCount)
			.def("GetOfficialModuleCount", &PresetMan::GetOfficialModuleCount)
			.def("AddPreset", &PresetMan::AddEntityPreset)
			.def_readwrite("Modules", &PresetMan::m_pDataModules, luabind::return_stl_iterator())
			// Disambiguate overloaded member funcs
			.def("GetPreset", (const Entity *(PresetMan::*)(string, string, int))&PresetMan::GetEntityPreset)
			.def("GetPreset", (const Entity *(PresetMan::*)(string, string, string))&PresetMan::GetEntityPreset)
			.def("GetLoadout", (Actor * (PresetMan::*)(std::string, std::string, bool))&PresetMan::GetLoadout, luabind::adopt_policy<0>())
			.def("GetLoadout", (Actor * (PresetMan::*)(std::string, int, bool))&PresetMan::GetLoadout, luabind::adopt_policy<0>())
			.def("GetRandomOfGroup", &PresetMan::GetRandomOfGroup)
			.def("GetRandomOfGroupInModuleSpace", &PresetMan::GetRandomOfGroupInModuleSpace)
			.def("GetEntityDataLocation", &PresetMan::GetEntityDataLocation)
			.def("ReadReflectedPreset", &PresetMan::ReadReflectedPreset)
			.def("ReloadAllScripts", &PresetMan::ReloadAllScripts),
	*/

		///////////////////////////////////////////////////////////////////////////

		sol::usertype<PresetMan> Bind = g_pSolLuaState->new_usertype<PresetMan>("PresetManager", sol::no_constructor);

		Bind["LoadDataModule"] = (bool (PresetMan::*)(string)) & PresetMan::LoadDataModule;
		Bind["GetDataModule"] = &PresetMan::GetDataModule;
		Bind["GetModuleID"] = &PresetMan::GetModuleID;
		Bind["GetModuleIDFromPath"] = &PresetMan::GetModuleIDFromPath;
		Bind["GetTotalModuleCount"] = &PresetMan::GetTotalModuleCount;
		Bind["GetOfficialModuleCount"] = &PresetMan::GetOfficialModuleCount;
		Bind["AddPreset"] = &PresetMan::AddEntityPreset;
		Bind["Modules"] = &PresetMan::m_pDataModules;
		// Disambiguate overloaded member funcs
		Bind["GetPreset"] = (const Entity * (PresetMan::*)(string, string, int)) & PresetMan::GetEntityPreset;
		Bind["GetPreset"] = (const Entity * (PresetMan::*)(string, string, string)) & PresetMan::GetEntityPreset;
		Bind["GetLoadout"] = (Actor * (PresetMan::*)(std::string, std::string, bool)) & PresetMan::GetLoadout, luabind::adopt_policy<0>();
		Bind["GetLoadout"] = (Actor * (PresetMan::*)(std::string, int, bool)) & PresetMan::GetLoadout, luabind::adopt_policy<0>();
		Bind["GetRandomOfGroup"] = &PresetMan::GetRandomOfGroup;
		Bind["GetRandomOfGroupInModuleSpace"] = &PresetMan::GetRandomOfGroupInModuleSpace;
		Bind["GetEntityDataLocation"] = &PresetMan::GetEntityDataLocation;
		Bind["ReadReflectedPreset"] = &PresetMan::ReadReflectedPreset;
		Bind["ReloadAllScripts"] = &PresetMan::ReloadAllScripts;//*/

	}

	{
		/*
		class_<AudioMan>("AudioManager")
			.property("SoundsVolume", &AudioMan::GetSoundsVolume, &AudioMan::SetSoundsVolume)
			.property("MusicVolume", &AudioMan::GetMusicVolume, &AudioMan::SetMusicVolume)
//            .def("PlayModule", &AudioMan::PlayModule)
			.def("PlayMusic", &AudioMan::PlayMusic)
			.def("QueueMusicStream", &AudioMan::QueueMusicStream)
			.def("QueueSilence", &AudioMan::QueueSilence)
			.def("ClearMusicQueue", &AudioMan::ClearMusicQueue)
			.def("PlaySound", (Sound * (AudioMan::*)(const char *, float, bool, bool, int))&AudioMan::PlaySound)
			.def("PlaySound", (void (AudioMan::*)(const char *))&AudioMan::PlaySound)
			.def("SetSoundAttenuation", &AudioMan::SetSoundAttenuation)
			.def("IsPlaying", &AudioMan::IsPlaying)
			.def("IsMusicPlaying", &AudioMan::IsMusicPlaying)
			//.def("StopSound", &AudioMan::StopSound)
			//.def("FadeOutSound", &AudioMan::FadeOutSound)
			.def("StopMusic", &AudioMan::StopMusic)
			.def("SetMusicPosition", &AudioMan::SetMusicPosition)
			.def("GetMusicPosition", &AudioMan::GetMusicPosition)
			.def("StopAll", &AudioMan::StopMusic),


		*/

		///////////////////////////////////////////////////////////////////////////

		sol::usertype<AudioMan> Bind = g_pSolLuaState->new_usertype<AudioMan>("AudioManager", sol::no_constructor);
		
		Bind["SoundsVolume"] = sol::property(&AudioMan::GetSoundsVolume, &AudioMan::SetSoundsVolume);
		Bind["MusicVolume"] = sol::property(&AudioMan::GetMusicVolume, &AudioMan::SetMusicVolume);
		//Bind["PlayModule"] =&AudioMan::PlayModule)
		Bind["PlayMusic"] = &AudioMan::PlayMusic;
		Bind["QueueMusicStream"] = &AudioMan::QueueMusicStream;
		Bind["QueueSilence"] = &AudioMan::QueueSilence;
		Bind["ClearMusicQueue"] = &AudioMan::ClearMusicQueue;
		Bind["PlaySound"] = (Sound * (AudioMan::*)(const char*, float, bool, bool, int)) & AudioMan::PlaySound;
		Bind["PlaySound"] = (void (AudioMan::*)(const char*)) & AudioMan::PlaySound;
		Bind["SetSoundAttenuation"] = &AudioMan::SetSoundAttenuation;
		Bind["IsPlaying"] = &AudioMan::IsPlaying;
		Bind["IsMusicPlaying"] = &AudioMan::IsMusicPlaying;
		//Bind["StopSound"] =&AudioMan::StopSound)
		//Bind["FadeOutSound"] =&AudioMan::FadeOutSound)
		Bind["StopMusic"] = &AudioMan::StopMusic;
		Bind["SetMusicPosition"] = &AudioMan::SetMusicPosition;
		Bind["GetMusicPosition"] = &AudioMan::GetMusicPosition;
		Bind["StopAll"] = &AudioMan::StopMusic;//*/
	}

	{
		/*
		class_<UInputMan>("UInputManager")
			.enum_("Players")
			[
				value("PLAYER_NONE", -1),
				value("PLAYER_ONE", 0),
				value("PLAYER_TWO", 1),
				value("PLAYER_THREE", 2),
				value("PLAYER_FOUR", 3),
				value("MAX_PLAYERS", 4)
			]
			.enum_("InputDevice")
			[
				value("DEVICE_KEYB_ONLY", 0),
				value("DEVICE_MOUSE_KEYB", 1),
				value("DEVICE_GAMEPAD_1", 2),
				value("DEVICE_GAMEPAD_2", 3),
				value("DEVICE_GAMEPAD_3", 4),
				value("DEVICE_GAMEPAD_4", 5),
				value("DEVICE_COUNT", 6)
			]
			.enum_("InputElements")
			[
				value("INPUT_L_UP", 0),
				value("INPUT_L_DOWN", 1),
				value("INPUT_L_LEFT", 2),
				value("INPUT_L_RIGHT", 3),
				value("INPUT_R_UP", 4),
				value("INPUT_R_DOWN", 5),
				value("INPUT_R_LEFT", 6),
				value("INPUT_R_RIGHT", 7),
				value("INPUT_FIRE", 8),
				value("INPUT_AIM", 9),
				value("INPUT_AIM_UP", 10),
				value("INPUT_AIM_DOWN", 11),
				value("INPUT_AIM_LEFT", 12),
				value("INPUT_AIM_RIGHT", 13),
				value("INPUT_PIEMENU", 14),
				value("INPUT_JUMP", 15),
				value("INPUT_CROUCH", 16),
				value("INPUT_NEXT", 17),
				value("INPUT_PREV", 18),
				value("INPUT_START", 19),
				value("INPUT_BACK", 20),
				value("INPUT_COUNT", 21)
			]
			.enum_("MouseButtons")
			[
				value("MOUSE_NONE", -1),
				value("MOUSE_LEFT", 0),
				value("MOUSE_RIGHT", 1),
				value("MOUSE_MIDDLE", 2),
				value("MAX_MOUSE_BUTTONS", 3)
			]
			.enum_("JoyButtons")
			[
				value("JOY_NONE", -1),
				value("JOY_1", 0),
				value("JOY_2", 1),
				value("JOY_3", 2),
				value("JOY_4", 3),
				value("JOY_5", 4),
				value("JOY_6", 5),
				value("JOY_7", 6),
				value("JOY_8", 7),
				value("JOY_9", 8),
				value("JOY_10", 9),
				value("JOY_11", 10),
				value("JOY_12", 11),
				value("MAX_JOY_BUTTONS", 12)
			]
			.enum_("JoyDirections")
			[
				value("JOYDIR_ONE", 0),
				value("JOYDIR_TWO", 1)
			]
			.def("ElementPressed", &UInputMan::ElementPressed)
			.def("ElementReleased", &UInputMan::ElementReleased)
			.def("ElementHeld", &UInputMan::ElementHeld)
			.def("KeyPressed", &UInputMan::KeyPressed)
			.def("KeyReleased", &UInputMan::KeyReleased)
			.def("KeyHeld", &UInputMan::KeyHeld)
			.def("WhichKeyHeld", &UInputMan::WhichKeyHeld)
			.def("MouseButtonPressed", (bool (UInputMan::*)(int,int))&UInputMan::MouseButtonPressed)
			.def("MouseButtonPressed", (bool (UInputMan::*)(int))&UInputMan::MouseButtonPressed)
			.def("MouseButtonReleased", (bool (UInputMan::*)(int, int))&UInputMan::MouseButtonReleased)
			.def("MouseButtonReleased", (bool (UInputMan::*)(int))&UInputMan::MouseButtonReleased)
			.def("MouseButtonHeld", (bool (UInputMan::*)(int, int))&UInputMan::MouseButtonHeld)
			.def("MouseButtonHeld", (bool (UInputMan::*)(int))&UInputMan::MouseButtonHeld)
			.def("MouseWheelMoved", &UInputMan::MouseWheelMoved)
			.def("JoyButtonPressed", &UInputMan::JoyButtonPressed)
			.def("JoyButtonReleased", &UInputMan::JoyButtonReleased)
			.def("JoyButtonHeld", &UInputMan::JoyButtonHeld)
			.def("WhichJoyButtonPressed", &UInputMan::WhichJoyButtonPressed)
			.def("JoyDirectionPressed", &UInputMan::JoyDirectionPressed)
			.def("JoyDirectionReleased", &UInputMan::JoyDirectionReleased)
			.def("JoyDirectionHeld", &UInputMan::JoyDirectionHeld)
			.def("AnalogMoveValues", &UInputMan::AnalogMoveValues)
			.def("AnalogAimValues", &UInputMan::AnalogAimValues)
			.def("SetMouseValueMagnitude", &UInputMan::SetMouseValueMagnitude)
			.def("AnalogAxisValue", &UInputMan::AnalogAxisValue)
			.def("AnalogStickValues", &UInputMan::AnalogStickValues)
			.def("MouseUsedByPlayer", &UInputMan::MouseUsedByPlayer)
			.def("AnyMouseButtonPress", &UInputMan::AnyMouseButtonPress)
			.def("TrapMousePos", &UInputMan::TrapMousePos)
			.def("GetMouseMovement", &UInputMan::GetMouseMovement)
			.def("DisableMouseMoving", &UInputMan::DisableMouseMoving)
			.def("SetMousePos", &UInputMan::SetMousePos)
			.def("ForceMouseWithinBox", &UInputMan::ForceMouseWithinBox)
			.def("ForceMouseWithinPlayerScreen", &UInputMan::ForceMouseWithinPlayerScreen)
			.def("AnyJoyInput", &UInputMan::AnyJoyInput)
			.def("AnyJoyPress", &UInputMan::AnyJoyPress)
			.def("AnyJoyButtonPress", &UInputMan::AnyJoyButtonPress)
			.def("AnyInput", &UInputMan::AnyInput)
			.def("AnyPress", &UInputMan::AnyPress)
			.def("AnyStartPress", &UInputMan::AnyStartPress)
			.property("FlagAltState", &UInputMan::FlagAltState)
			.property("FlagCtrlState", &UInputMan::FlagCtrlState)
			.property("FlagShiftState", &UInputMan::FlagShiftState),
		*/

		///////////////////////////////////////////////////////////////////////////

		sol::usertype<UInputMan> Bind = g_pSolLuaState->new_usertype<UInputMan>("UInputManager", sol::no_constructor);

		g_pSolLuaState->set("Players", g_pSolLuaState->create_table_with(
			"PLAYER_NONE", -1,
			"PLAYER_ONE", 0,
			"PLAYER_TWO", 1,
			"PLAYER_THREE", 2,
			"PLAYER_FOUR", 3,
			"MAX_PLAYERS", 4
		));

		g_pSolLuaState->set("InputDevice", g_pSolLuaState->create_table_with(
			"DEVICE_KEYB_ONLY", 0,
			"DEVICE_MOUSE_KEYB", 1,
			"DEVICE_GAMEPAD_1", 2,
			"DEVICE_GAMEPAD_2", 3,
			"DEVICE_GAMEPAD_3", 4,
			"DEVICE_GAMEPAD_4", 5,
			"DEVICE_COUNT", 6
		));

		g_pSolLuaState->set("InputElements", g_pSolLuaState->create_table_with(
			"INPUT_L_UP", 0,
			"INPUT_L_DOWN", 1,
			"INPUT_L_LEFT", 2,
			"INPUT_L_RIGHT", 3,
			"INPUT_R_UP", 4,
			"INPUT_R_DOWN", 5,
			"INPUT_R_LEFT", 6,
			"INPUT_R_RIGHT", 7,
			"INPUT_FIRE", 8,
			"INPUT_AIM", 9,
			"INPUT_AIM_UP", 10,
			"INPUT_AIM_DOWN", 11,
			"INPUT_AIM_LEFT", 12,
			"INPUT_AIM_RIGHT", 13,
			"INPUT_PIEMENU", 14,
			"INPUT_JUMP", 15,
			"INPUT_CROUCH", 16,
			"INPUT_NEXT", 17,
			"INPUT_PREV", 18,
			"INPUT_START", 19,
			"INPUT_BACK", 20,
			"INPUT_COUNT", 21
		));

		g_pSolLuaState->set("MouseButtons", g_pSolLuaState->create_table_with(
			"MOUSE_NONE", -1,
			"MOUSE_LEFT", 0,
			"MOUSE_RIGHT", 1,
			"MOUSE_MIDDLE", 2,
			"MAX_MOUSE_BUTTONS", 3
		));

		g_pSolLuaState->set("JoyButtons", g_pSolLuaState->create_table_with(
			"JOY_NONE", -1,
			"JOY_1", 0,
			"JOY_2", 1,
			"JOY_3", 2,
			"JOY_4", 3,
			"JOY_5", 4,
			"JOY_6", 5,
			"JOY_7", 6,
			"JOY_8", 7,
			"JOY_9", 8,
			"JOY_10", 9,
			"JOY_11", 10,
			"JOY_12", 11,
			"MAX_JOY_BUTTONS", 12
		));

		g_pSolLuaState->set("JoyDirections", g_pSolLuaState->create_table_with(
			"JOYDIR_ONE", 0,
			"JOYDIR_TWO", 1
		));

		Bind["ElementPressed"] = &UInputMan::ElementPressed;
		Bind["ElementReleased"] = &UInputMan::ElementReleased;
		Bind["ElementHeld"] = &UInputMan::ElementHeld;
		Bind["KeyPressed"] = &UInputMan::KeyPressed;
		Bind["KeyReleased"] = &UInputMan::KeyReleased;
		Bind["KeyHeld"] = &UInputMan::KeyHeld;
		Bind["WhichKeyHeld"] = &UInputMan::WhichKeyHeld;
		Bind["MouseButtonPressed"] = (bool (UInputMan::*)(int, int)) & UInputMan::MouseButtonPressed;
		Bind["MouseButtonPressed"] = (bool (UInputMan::*)(int)) & UInputMan::MouseButtonPressed;
		Bind["MouseButtonReleased"] = (bool (UInputMan::*)(int, int)) & UInputMan::MouseButtonReleased;
		Bind["MouseButtonReleased"] = (bool (UInputMan::*)(int)) & UInputMan::MouseButtonReleased;
		Bind["MouseButtonHeld"] = (bool (UInputMan::*)(int, int)) & UInputMan::MouseButtonHeld;
		Bind["MouseButtonHeld"] = (bool (UInputMan::*)(int)) & UInputMan::MouseButtonHeld;
		Bind["MouseWheelMoved"] = &UInputMan::MouseWheelMoved;
		Bind["JoyButtonPressed"] = &UInputMan::JoyButtonPressed;
		Bind["JoyButtonReleased"] = &UInputMan::JoyButtonReleased;
		Bind["JoyButtonHeld"] = &UInputMan::JoyButtonHeld;
		Bind["WhichJoyButtonPressed"] = &UInputMan::WhichJoyButtonPressed;
		Bind["JoyDirectionPressed"] = &UInputMan::JoyDirectionPressed;
		Bind["JoyDirectionReleased"] = &UInputMan::JoyDirectionReleased;
		Bind["JoyDirectionHeld"] = &UInputMan::JoyDirectionHeld;
		Bind["AnalogMoveValues"] = &UInputMan::AnalogMoveValues;
		Bind["AnalogAimValues"] = &UInputMan::AnalogAimValues;
		Bind["SetMouseValueMagnitude"] = &UInputMan::SetMouseValueMagnitude;
		Bind["AnalogAxisValue"] = &UInputMan::AnalogAxisValue;
		Bind["AnalogStickValues"] = &UInputMan::AnalogStickValues;
		Bind["MouseUsedByPlayer"] = &UInputMan::MouseUsedByPlayer;
		Bind["AnyMouseButtonPress"] = &UInputMan::AnyMouseButtonPress;
		Bind["TrapMousePos"] = &UInputMan::TrapMousePos;
		Bind["GetMouseMovement"] = &UInputMan::GetMouseMovement;
		Bind["DisableMouseMoving"] = &UInputMan::DisableMouseMoving;
		Bind["SetMousePos"] = &UInputMan::SetMousePos;
		Bind["ForceMouseWithinBox"] = &UInputMan::ForceMouseWithinBox;
		Bind["ForceMouseWithinPlayerScreen"] = &UInputMan::ForceMouseWithinPlayerScreen;
		Bind["AnyJoyInput"] = &UInputMan::AnyJoyInput;
		Bind["AnyJoyPress"] = &UInputMan::AnyJoyPress;
		Bind["AnyJoyButtonPress"] = &UInputMan::AnyJoyButtonPress;
		Bind["AnyInput"] = &UInputMan::AnyInput;
		Bind["AnyPress"] = &UInputMan::AnyPress;
		Bind["AnyStartPress"] = &UInputMan::AnyStartPress;
		Bind["FlagAltState"] = sol::property(&UInputMan::FlagAltState);
		Bind["FlagCtrlState"] = sol::property(&UInputMan::FlagCtrlState);
		Bind["FlagShiftState"] = sol::property(&UInputMan::FlagShiftState);//*/
	}

	{
		/*
		class_<IntRect>("IntRect")
			.def(luabind::constructor<>())
			.def(luabind::constructor<int, int, int, int>())
			.def_readwrite("Left", &IntRect::m_Left)
			.def_readwrite("Top", &IntRect::m_Top)
			.def_readwrite("Right", &IntRect::m_Right)
			.def_readwrite("Bottom", &IntRect::m_Bottom),
		*/

		///////////////////////////////////////////////////////////////////////////

		sol::usertype<IntRect> Bind = g_pSolLuaState->new_usertype<IntRect>("IntRect",
			sol::constructors<IntRect(), IntRect(int, int, int, int)>()
		);

		Bind["Left"] = &IntRect::m_Left;
		Bind["Top"] = &IntRect::m_Top;
		Bind["Right"] = &IntRect::m_Right;
		Bind["Bottom"] = &IntRect::m_Bottom;//*/
	}

	{
		/*
			CONCRETELUABINDING(Scene, Entity)
			.enum_("PlacedObjectSets")
			[
				value("PLACEONLOAD", 0),
				value("BLUEPRINT", 1),
				value("AIPLAN", 2),
				value("PLACEDSETSCOUNT", 3)
			]
			.property("Location", &Scene::GetLocation, &Scene::SetLocation)
			//            .property("Terrain", &Scene::GetTerrain)
			.property("Dimensions", &Scene::GetDimensions)
			.property("Width", &Scene::GetWidth)
			.property("Height", &Scene::GetHeight)
			.property("WrapsX", &Scene::WrapsX)
			.property("WrapsY", &Scene::WrapsY)
			.property("TeamOwnership", &Scene::GetTeamOwnership, &Scene::SetTeamOwnership)
			.def("GetBuildBudget", &Scene::GetBuildBudget)
			.def("SetBuildBudget", &Scene::SetBuildBudget)
			.def("IsScanScheduled", &Scene::IsScanScheduled)
			.def("SetScheduledScan", &Scene::SetScheduledScan)
			.def("ClearPlacedObjectSet", &Scene::ClearPlacedObjectSet)
			.def("PlaceResidentBrain", &Scene::PlaceResidentBrain)
			.def("PlaceResidentBrains", &Scene::PlaceResidentBrains)
			.def("RetrieveResidentBrains", &Scene::RetrieveResidentBrains)
			.def("GetResidentBrain", &Scene::GetResidentBrain)
			.def("SetResidentBrain", &Scene::SetResidentBrain)
			.def("SetArea", &Scene::SetArea)
			.def("HasArea", &Scene::HasArea)
			.def("GetArea", &Scene::GetArea)
			.def("GetOptionalArea", &Scene::GetOptionalArea)
			.def("WithinArea", &Scene::WithinArea)
			.property("GlobalAcc", &Scene::GetGlobalAcc, &Scene::SetGlobalAcc)
			.property("GlocalAcc", &Scene::GetGlobalAcc, &Scene::SetGlobalAcc)
			.def("ResetPathFinding", &Scene::ResetPathFinding)
			.def("UpdatePathFinding", &Scene::UpdatePathFinding)
			.def("PathFindingUpdated", &Scene::PathFindingUpdated)
			.def("CalculatePath", &Scene::CalculateScenePath)
			.def_readwrite("ScenePath", &Scene::m_ScenePath, luabind::return_stl_iterator())
			.def_readwrite("Deployments", &Scene::m_Deployments, luabind::return_stl_iterator())
			.property("ScenePathSize", &Scene::GetScenePathSize),
		*/

		///////////////////////////////////////////////////////////////////////////

		CONCRETELUABINDING_SOL(Scene, Entity);
		 
		g_pSolLuaState->set("PlacedObjectSets", g_pSolLuaState->create_table_with(
			"PLACEONLOAD", 0,
			"BLUEPRINT", 1,
			"AIPLAN", 2,
			"PLACEDSETSCOUNT", 3
		));

		Bind["Location"] = sol::property(&Scene::GetLocation, &Scene::SetLocation);
		//            Bind["Terrain"] = sol::property(&Scene::GetTerrain);
		Bind["Dimensions"] = sol::property(&Scene::GetDimensions);
		Bind["Width"] = sol::property(&Scene::GetWidth);
		Bind["Height"] = sol::property(&Scene::GetHeight);
		Bind["WrapsX"] = sol::property(&Scene::WrapsX);
		Bind["WrapsY"] = sol::property(&Scene::WrapsY);
		Bind["TeamOwnership"] = sol::property(&Scene::GetTeamOwnership, &Scene::SetTeamOwnership);
		Bind["GetBuildBudget"] = &Scene::GetBuildBudget;
		Bind["SetBuildBudget"] = &Scene::SetBuildBudget;
		Bind["IsScanScheduled"] = &Scene::IsScanScheduled;
		Bind["SetScheduledScan"] = &Scene::SetScheduledScan;
		Bind["ClearPlacedObjectSet"] = &Scene::ClearPlacedObjectSet;
		Bind["PlaceResidentBrain"] = &Scene::PlaceResidentBrain;
		Bind["PlaceResidentBrains"] = &Scene::PlaceResidentBrains;
		Bind["RetrieveResidentBrains"] = &Scene::RetrieveResidentBrains;
		Bind["GetResidentBrain"] = &Scene::GetResidentBrain;
		Bind["SetResidentBrain"] = &Scene::SetResidentBrain;
		Bind["SetArea"] = &Scene::SetArea;
		Bind["HasArea"] = &Scene::HasArea;
		Bind["GetArea"] = &Scene::GetArea;
		Bind["GetOptionalArea"] = &Scene::GetOptionalArea;
		Bind["WithinArea"] = &Scene::WithinArea;
		Bind["GlobalAcc"] = sol::property(&Scene::GetGlobalAcc, &Scene::SetGlobalAcc);
		Bind["GlocalAcc"] = sol::property(&Scene::GetGlobalAcc, &Scene::SetGlobalAcc);
		Bind["ResetPathFinding"] = &Scene::ResetPathFinding;
		Bind["UpdatePathFinding"] = &Scene::UpdatePathFinding;
		Bind["PathFindingUpdated"] = &Scene::PathFindingUpdated;
		Bind["CalculatePath"] = &Scene::CalculateScenePath;
		Bind["ScenePath"] = sol::property(&Scene::m_ScenePath);
		Bind["Deployments"] = sol::property(&Scene::m_Deployments);
		Bind["ScenePathSize"] = sol::property(&Scene::GetScenePathSize);//*/
	}

	{
		/*
		ABSTRACTLUABINDING(Deployment, SceneObject)
			.def("CreateDeployedActor", (Actor * (Deployment::*)())&Deployment::CreateDeployedActor, luabind::adopt_policy<0>())
			.def("CreateDeployedObject", (SceneObject * (Deployment::*)())&Deployment::CreateDeployedObject, luabind::adopt_policy<0>())
			.def("GetLoadoutName", &Deployment::GetLoadoutName)
			.property("SpawnRadius", &Deployment::GetSpawnRadius)
			.property("ID", &Deployment::GetID)
			.property("HFlipped", &Deployment::IsHFlipped),
		*/

		///////////////////////////////////////////////////////////////////////////

		ABSTRACTLUABINDING_SOL(Deployment, SceneObject);

		Bind["CreateDeployedActor"] = (Actor * (Deployment::*)()) & Deployment::CreateDeployedActor;
		Bind["CreateDeployedObject"] = (SceneObject * (Deployment::*)()) & Deployment::CreateDeployedObject;
		Bind["GetLoadoutName"] = &Deployment::GetLoadoutName;
		Bind["SpawnRadius"] = sol::property(&Deployment::GetSpawnRadius);
		Bind["ID"] = sol::property(&Deployment::GetID);
		Bind["HFlipped"] = sol::property(&Deployment::IsHFlipped);//*/
	}

	{
		/*
		class_<SceneMan>("SceneManager")
			.property("Scene", &SceneMan::GetScene)
			.def("LoadScene", (int (SceneMan::*)(string, bool, bool))&SceneMan::LoadScene)
			.def("LoadScene", (int (SceneMan::*)(string, bool))&SceneMan::LoadScene)
			.property("SceneDim", &SceneMan::GetSceneDim)
			.property("SceneWidth", &SceneMan::GetSceneWidth)
			.property("SceneHeight", &SceneMan::GetSceneHeight)
			.property("SceneWrapsX", &SceneMan::SceneWrapsX)
			.property("SceneWrapsY", &SceneMan::SceneWrapsY)
			.def("GetOffset", &SceneMan::GetOffset)
			.def("SetOffset", (void (SceneMan::*)(const Vector &, int))&SceneMan::SetOffset)
			.def("SetOffsetX", &SceneMan::SetOffsetX)
			.def("SetOffsetY", &SceneMan::SetOffsetY)
			.def("GetScreenOcclusion", &SceneMan::GetScreenOcclusion)
			.def("SetScreenOcclusion", &SceneMan::SetScreenOcclusion)
			.def("GetTerrain", &SceneMan::GetTerrain)
			.def("GetMaterial", &SceneMan::GetMaterial)
			.def("GetMaterialFromID", &SceneMan::GetMaterialFromID)
//            .property("MOColorBitmap", &SceneMan::GetMOColorBitmap)
//            .property("DebugBitmap", &SceneMan::GetDebugBitmap)
//            .property("MOIDBitmap", &SceneMan::GetMOIDBitmap)
			.property("LayerDrawMode", &SceneMan::GetLayerDrawMode, &SceneMan::SetLayerDrawMode)
			.def("GetTerrMatter", &SceneMan::GetTerrMatter)
			.def("GetMOIDPixel", &SceneMan::GetMOIDPixel)
			.property("GlobalAcc", &SceneMan::GetGlobalAcc)
			.property("OzPerKg", &SceneMan::GetOzPerKg)
			.property("KgPerOz", &SceneMan::GetKgPerOz)
			.def("SetLayerDrawMode", &SceneMan::SetLayerDrawMode)
			.def("SetScroll", &SceneMan::SetScroll)
			.def("SetScrollTarget", &SceneMan::SetScrollTarget)
			.def("GetScrollTarget", &SceneMan::GetScrollTarget)
			.def("TargetDistanceScalar", &SceneMan::TargetDistanceScalar)
			.def("CheckOffset", &SceneMan::CheckOffset)
			.def("LoadUnseenLayer", &SceneMan::LoadUnseenLayer)
			.def("MakeAllUnseen", &SceneMan::MakeAllUnseen)
			.def("AnythingUnseen", &SceneMan::AnythingUnseen)
			.def("GetUnseenResolution", &SceneMan::GetUnseenResolution)
			.def("IsUnseen", &SceneMan::IsUnseen)
			.def("RevealUnseen", &SceneMan::RevealUnseen)
			.def("RevealUnseenBox", &SceneMan::RevealUnseenBox)
			.def("RestoreUnseen", &SceneMan::RestoreUnseen)
			.def("RestoreUnseenBox", &SceneMan::RestoreUnseenBox)
			.def("CastSeeRay", &SceneMan::CastSeeRay)
			.def("CastUnseeRay", &SceneMan::CastUnseeRay)
			.def("CastUnseenRay", &SceneMan::CastUnseenRay)
			.def("CastMaterialRay", (bool (SceneMan::*)(const Vector &, const Vector &, unsigned char, Vector &, int, bool))&SceneMan::CastMaterialRay)
			.def("CastMaterialRay", (float (SceneMan::*)(const Vector &, const Vector &, unsigned char, int))&SceneMan::CastMaterialRay)
			.def("CastNotMaterialRay", (bool (SceneMan::*)(const Vector &, const Vector &, unsigned char, Vector &, int, bool))&SceneMan::CastNotMaterialRay)
			.def("CastNotMaterialRay", (float (SceneMan::*)(const Vector &, const Vector &, unsigned char, int, bool))&SceneMan::CastNotMaterialRay)
			.def("CastStrengthSumRay", &SceneMan::CastStrengthSumRay)
			.def("CastMaxStrengthRay", &SceneMan::CastMaxStrengthRay)
			.def("CastStrengthRay", &SceneMan::CastStrengthRay)
			.def("CastWeaknessRay", &SceneMan::CastWeaknessRay)
			.def("CastMORay", &SceneMan::CastMORay)
			.def("CastFindMORay", &SceneMan::CastFindMORay)
			.def("CastObstacleRay", &SceneMan::CastObstacleRay)
			.def("GetLastRayHitPos", &SceneMan::GetLastRayHitPos)
			.def("FindAltitude", &SceneMan::FindAltitude)
			.def("MovePointToGround", &SceneMan::MovePointToGround)
			.def("IsWithinBounds", &SceneMan::IsWithinBounds)
//			.def("ForceBounds", (bool (SceneMan::*)(int *, int *))&SceneMan::ForceBounds)
			.def("ForceBounds", (bool (SceneMan::*)(Vector &))&SceneMan::ForceBounds)//, out_value(_2))
//            .def("WrapPosition", (bool (SceneMan::*)(int *, int *))&SceneMan::WrapPosition)
			.def("WrapPosition", (bool (SceneMan::*)(Vector &))&SceneMan::WrapPosition)//, out_value(_2))
			.def("SnapPosition", &SceneMan::SnapPosition)
			.def("ShortestDistance", &SceneMan::ShortestDistance)
			.def("ObscuredPoint", (bool (SceneMan::*)(Vector &, int))&SceneMan::ObscuredPoint)//, out_value(_2))
			.def("ObscuredPoint", (bool (SceneMan::*)(int, int, int))&SceneMan::ObscuredPoint)
			.def("RegisterPostEffect", &SceneMan::RegisterPostEffect)
			.def("AddSceneObject", &SceneMan::AddSceneObject)
			.def("AddTerrainObject", &SceneMan::AddTerrainObject)
			.def("CheckAndRemoveOrphans", (int (SceneMan::*)(int, int, int, int, bool))&SceneMan::RemoveOrphans)
			.def("ClearPostEffects", &SceneMan::ClearPostEffects),
		*/

		///////////////////////////////////////////////////////////////////////////

		sol::usertype<IntRect> Bind = g_pSolLuaState->new_usertype<IntRect>("SceneManager", sol::no_constructor);

		Bind["Scene"] = sol::property(&SceneMan::GetScene);
		Bind["LoadScene"] = (int (SceneMan::*)(string, bool, bool)) & SceneMan::LoadScene;
		Bind["LoadScene"] = (int (SceneMan::*)(string, bool)) & SceneMan::LoadScene;
		Bind["SceneDim"] = sol::property(&SceneMan::GetSceneDim);
		Bind["SceneWidth"] = sol::property(&SceneMan::GetSceneWidth);
		Bind["SceneHeight"] = sol::property(&SceneMan::GetSceneHeight);
		Bind["SceneWrapsX"] = sol::property(&SceneMan::SceneWrapsX);
		Bind["SceneWrapsY"] = sol::property(&SceneMan::SceneWrapsY);
		Bind["GetOffset"] = &SceneMan::GetOffset;
		Bind["SetOffset"] = (void (SceneMan::*)(const Vector&, int)) & SceneMan::SetOffset;
		Bind["SetOffsetX"] = &SceneMan::SetOffsetX;
		Bind["SetOffsetY"] = &SceneMan::SetOffsetY;
		Bind["GetScreenOcclusion"] = &SceneMan::GetScreenOcclusion;
		Bind["SetScreenOcclusion"] = &SceneMan::SetScreenOcclusion;
		Bind["GetTerrain"] = &SceneMan::GetTerrain;
		Bind["GetMaterial"] = &SceneMan::GetMaterial;
		Bind["GetMaterialFromID"] = &SceneMan::GetMaterialFromID;
		//            Bind["MOColorBitmap"] = &SceneMan::GetMOColorBitmap)
		//            Bind["DebugBitmap"] = &SceneMan::GetDebugBitmap)
		//            Bind["MOIDBitmap"] = &SceneMan::GetMOIDBitmap)
		Bind["LayerDrawMode"] = sol::property(&SceneMan::GetLayerDrawMode, &SceneMan::SetLayerDrawMode);
		Bind["GetTerrMatter"] = &SceneMan::GetTerrMatter;
		Bind["GetMOIDPixel"] = &SceneMan::GetMOIDPixel;
		Bind["GlobalAcc"] = sol::property(&SceneMan::GetGlobalAcc);
		Bind["OzPerKg"] = sol::property(&SceneMan::GetOzPerKg);
		Bind["KgPerOz"] = sol::property(&SceneMan::GetKgPerOz);
		Bind["SetLayerDrawMode"] = &SceneMan::SetLayerDrawMode;
		Bind["SetScroll"] = &SceneMan::SetScroll;
		Bind["SetScrollTarget"] = &SceneMan::SetScrollTarget;
		Bind["GetScrollTarget"] = &SceneMan::GetScrollTarget;
		Bind["TargetDistanceScalar"] = &SceneMan::TargetDistanceScalar;
		Bind["CheckOffset"] = &SceneMan::CheckOffset;
		Bind["LoadUnseenLayer"] = &SceneMan::LoadUnseenLayer;
		Bind["MakeAllUnseen"] = &SceneMan::MakeAllUnseen;
		Bind["AnythingUnseen"] = &SceneMan::AnythingUnseen;
		Bind["GetUnseenResolution"] = &SceneMan::GetUnseenResolution;
		Bind["IsUnseen"] = &SceneMan::IsUnseen;
		Bind["RevealUnseen"] = &SceneMan::RevealUnseen;
		Bind["RevealUnseenBox"] = &SceneMan::RevealUnseenBox;
		Bind["RestoreUnseen"] = &SceneMan::RestoreUnseen;
		Bind["RestoreUnseenBox"] = &SceneMan::RestoreUnseenBox;
		Bind["CastSeeRay"] = &SceneMan::CastSeeRay;
		Bind["CastUnseeRay"] = &SceneMan::CastUnseeRay;
		Bind["CastUnseenRay"] = &SceneMan::CastUnseenRay;
		Bind["CastMaterialRay"] = (bool (SceneMan::*)(const Vector&, const Vector&, unsigned char, Vector&, int, bool)) & SceneMan::CastMaterialRay;
		Bind["CastMaterialRay"] = (float (SceneMan::*)(const Vector&, const Vector&, unsigned char, int)) & SceneMan::CastMaterialRay;
		Bind["CastNotMaterialRay"] = (bool (SceneMan::*)(const Vector&, const Vector&, unsigned char, Vector&, int, bool)) & SceneMan::CastNotMaterialRay;
		Bind["CastNotMaterialRay"] = (float (SceneMan::*)(const Vector&, const Vector&, unsigned char, int, bool)) & SceneMan::CastNotMaterialRay;
		Bind["CastStrengthSumRay"] = &SceneMan::CastStrengthSumRay;
		Bind["CastMaxStrengthRay"] = &SceneMan::CastMaxStrengthRay;
		Bind["CastStrengthRay"] = &SceneMan::CastStrengthRay;
		Bind["CastWeaknessRay"] = &SceneMan::CastWeaknessRay;
		Bind["CastMORay"] = &SceneMan::CastMORay;
		Bind["CastFindMORay"] = &SceneMan::CastFindMORay;
		Bind["CastObstacleRay"] = &SceneMan::CastObstacleRay;
		Bind["GetLastRayHitPos"] = &SceneMan::GetLastRayHitPos;
		Bind["FindAltitude"] = &SceneMan::FindAltitude;
		Bind["MovePointToGround"] = &SceneMan::MovePointToGround;
		Bind["IsWithinBounds"] = &SceneMan::IsWithinBounds;
//			Bind["ForceBounds"] = (bool (SceneMan::*)(int *, int *))&SceneMan::ForceBounds)
		Bind["ForceBounds"] = (bool (SceneMan::*)(Vector&)) & SceneMan::ForceBounds;//, out_value(_2))
//            Bind["WrapPosition"] = (bool (SceneMan::*)(int *, int *))&SceneMan::WrapPosition)
		Bind["WrapPosition"] = (bool (SceneMan::*)(Vector&)) & SceneMan::WrapPosition;//, out_value(_2))
		Bind["SnapPosition"] = &SceneMan::SnapPosition;
		Bind["ShortestDistance"] = &SceneMan::ShortestDistance;
		Bind["ObscuredPoint"] = (bool (SceneMan::*)(Vector&, int)) & SceneMan::ObscuredPoint;//, out_value(_2))
		Bind["ObscuredPoint"] = (bool (SceneMan::*)(int, int, int)) & SceneMan::ObscuredPoint;
		Bind["RegisterPostEffect"] = &SceneMan::RegisterPostEffect;
		Bind["AddSceneObject"] = &SceneMan::AddSceneObject;
		Bind["AddTerrainObject"] = &SceneMan::AddTerrainObject;
		Bind["CheckAndRemoveOrphans"] = (int (SceneMan::*)(int, int, int, int, bool)) & SceneMan::RemoveOrphans;
		Bind["ClearPostEffects"] = &SceneMan::ClearPostEffects;//*/
	}

	{
		/*
		class_<DataModule>("DataModule")
			.def_readwrite("Presets", &DataModule::m_EntityList, luabind::return_stl_iterator())
			.property("FileName", &DataModule::GetFileName)
			.property("FriendlyName", &DataModule::GetFriendlyName),
		*/

		///////////////////////////////////////////////////////////////////////////

		sol::usertype<DataModule> Bind = g_pSolLuaState->new_usertype<DataModule>("DataModule", sol::no_constructor);

		Bind["Presets"] = &DataModule::m_EntityList;
		Bind["FileName"] = sol::property(&DataModule::GetFileName);
		Bind["FriendlyName"] = sol::property(&DataModule::GetFriendlyName);
	}

	{
		/*
		class_<BuyMenuGUI>("BuyMenuGUI")
			.def("SetMetaPlayer", &BuyMenuGUI::SetMetaPlayer)
			.def("SetNativeTechModule", &BuyMenuGUI::SetNativeTechModule)
			.def("SetForeignCostMultiplier", &BuyMenuGUI::SetForeignCostMultiplier)
			.def("SetModuleExpanded", &BuyMenuGUI::SetModuleExpanded)
			.def("LoadAllLoadoutsFromFile", &BuyMenuGUI::LoadAllLoadoutsFromFile)
			.def("AddAllowedItem", &BuyMenuGUI::AddAllowedItem)
			.def("RemoveAllowedItem", &BuyMenuGUI::RemoveAllowedItem)
			.def("ClearAllowedItems", &BuyMenuGUI::ClearAllowedItems)
			.def("AddAlwaysAllowedItem", &BuyMenuGUI::AddAlwaysAllowedItem)
			.def("RemoveAlwaysAllowedItem", &BuyMenuGUI::RemoveAlwaysAllowedItem)
			.def("ClearAlwaysAllowedItems", &BuyMenuGUI::ClearAlwaysAllowedItems)
			.def("AddProhibitedItem", &BuyMenuGUI::AddProhibitedItem)
			.def("RemoveProhibitedItem", &BuyMenuGUI::RemoveProhibitedItem)
			.def("ClearProhibitedItems", &BuyMenuGUI::ClearProhibitedItems)
			.def("ForceRefresh", &BuyMenuGUI::ForceRefresh)
			.def("SetOwnedItemsAmount", &BuyMenuGUI::SetOwnedItemsAmount)
			.def("GetOwnedItemsAmount", &BuyMenuGUI::GetOwnedItemsAmount)
			.def("SetHeaderImage", &BuyMenuGUI::SetHeaderImage)
			.def("SetLogoImage", &BuyMenuGUI::SetLogoImage)
			.def("ClearCartList", &BuyMenuGUI::ClearCartList)
			.def("LoadDefaultLoadoutToCart", &BuyMenuGUI::LoadDefaultLoadoutToCart)
			.property("ShowOnlyOwnedItems", &BuyMenuGUI::GetOnlyShowOwnedItems, &BuyMenuGUI::SetOnlyShowOwnedItems)
			.property("EnforceMaxPassengersConstraint", &BuyMenuGUI::EnforceMaxPassengersConstraint, &BuyMenuGUI::SetEnforceMaxPassengersConstraint)
			.property("EnforceMaxMassConstraint", &BuyMenuGUI::EnforceMaxMassConstraint, &BuyMenuGUI::SetEnforceMaxMassConstraint),
		*/

		///////////////////////////////////////////////////////////////////////////

		sol::usertype<BuyMenuGUI> Bind = g_pSolLuaState->new_usertype<BuyMenuGUI>("BuyMenuGUI", sol::no_constructor);

		Bind["SetMetaPlayer"] = &BuyMenuGUI::SetMetaPlayer;
		Bind["SetNativeTechModule"] = &BuyMenuGUI::SetNativeTechModule;
		Bind["SetForeignCostMultiplier"] = &BuyMenuGUI::SetForeignCostMultiplier;
		Bind["SetModuleExpanded"] = &BuyMenuGUI::SetModuleExpanded;
		Bind["LoadAllLoadoutsFromFile"] = &BuyMenuGUI::LoadAllLoadoutsFromFile;
		Bind["AddAllowedItem"] = &BuyMenuGUI::AddAllowedItem;
		Bind["RemoveAllowedItem"] = &BuyMenuGUI::RemoveAllowedItem;
		Bind["ClearAllowedItems"] = &BuyMenuGUI::ClearAllowedItems;
		Bind["AddAlwaysAllowedItem"] = &BuyMenuGUI::AddAlwaysAllowedItem;
		Bind["RemoveAlwaysAllowedItem"] = &BuyMenuGUI::RemoveAlwaysAllowedItem;
		Bind["ClearAlwaysAllowedItems"] = &BuyMenuGUI::ClearAlwaysAllowedItems;
		Bind["AddProhibitedItem"] = &BuyMenuGUI::AddProhibitedItem;
		Bind["RemoveProhibitedItem"] = &BuyMenuGUI::RemoveProhibitedItem;
		Bind["ClearProhibitedItems"] = &BuyMenuGUI::ClearProhibitedItems;
		Bind["ForceRefresh"] = &BuyMenuGUI::ForceRefresh;
		Bind["SetOwnedItemsAmount"] = &BuyMenuGUI::SetOwnedItemsAmount;
		Bind["GetOwnedItemsAmount"] = &BuyMenuGUI::GetOwnedItemsAmount;
		Bind["SetHeaderImage"] = &BuyMenuGUI::SetHeaderImage;
		Bind["SetLogoImage"] = &BuyMenuGUI::SetLogoImage;
		Bind["ClearCartList"] = &BuyMenuGUI::ClearCartList;
		Bind["LoadDefaultLoadoutToCart"] = &BuyMenuGUI::LoadDefaultLoadoutToCart;
		Bind["ShowOnlyOwnedItems"] = sol::property(&BuyMenuGUI::GetOnlyShowOwnedItems, &BuyMenuGUI::SetOnlyShowOwnedItems);
		Bind["EnforceMaxPassengersConstraint"] = sol::property(&BuyMenuGUI::EnforceMaxPassengersConstraint, &BuyMenuGUI::SetEnforceMaxPassengersConstraint);
		Bind["EnforceMaxMassConstraint"] = sol::property(&BuyMenuGUI::EnforceMaxMassConstraint, &BuyMenuGUI::SetEnforceMaxMassConstraint);//*/
	}

	{
		/*
		class_<SceneEditorGUI>("SceneEditorGUI")
			.enum_("EditorGUIMode")
			[
				value("INACTIVE", 0),
				value("PICKINGOBJECT", 1),
				value("ADDINGOBJECT", 2),
				value("INSTALLINGBRAIN", 3),
				value("PLACINGOBJECT", 4),
				value("MOVINGOBJECT", 5),
				value("DELETINGOBJECT", 6),
				value("PLACEINFRONT", 7),
				value("PLACEBEHIND", 8),
				value("DONEEDITING", 9),
				value("EDITORGUIMODECOUNT", 10)
			]
			.def("SetCursorPos", &SceneEditorGUI::SetCursorPos)
			.property("EditorMode", &SceneEditorGUI::GetEditorGUIMode, &SceneEditorGUI::SetEditorGUIMode)
			.def("GetCurrentObject", &SceneEditorGUI::GetCurrentObject)
			.def("SetCurrentObject", &SceneEditorGUI::SetCurrentObject)
			.def("SetModuleSpace", &SceneEditorGUI::SetModuleSpace)
			.def("SetNativeTechModule", &SceneEditorGUI::SetNativeTechModule)
			.def("SetForeignCostMultiplier", &SceneEditorGUI::SetForeignCostMultiplier)
			.def("TestBrainResidence", &SceneEditorGUI::TestBrainResidence)
			.def("Update", &SceneEditorGUI::Update),
		*/

		///////////////////////////////////////////////////////////////////////////

		sol::usertype<SceneEditorGUI> Bind = g_pSolLuaState->new_usertype<SceneEditorGUI>("SceneEditorGUI", sol::no_constructor);

		g_pSolLuaState->set("PlacedObjectSets", g_pSolLuaState->create_table_with(
			"INACTIVE", 0,
			"PICKINGOBJECT", 1,
			"ADDINGOBJECT", 2,
			"INSTALLINGBRAIN", 3,
			"PLACINGOBJECT", 4,
			"MOVINGOBJECT", 5,
			"DELETINGOBJECT", 6,
			"PLACEINFRONT", 7,
			"PLACEBEHIND", 8,
			"DONEEDITING", 9,
			"EDITORGUIMODECOUNT", 10
		));

		Bind["SetCursorPos"] = &SceneEditorGUI::SetCursorPos;
		Bind["EditorMode"] = sol::property(&SceneEditorGUI::GetEditorGUIMode, &SceneEditorGUI::SetEditorGUIMode);
		Bind["GetCurrentObject"] = &SceneEditorGUI::GetCurrentObject;
		Bind["SetCurrentObject"] = &SceneEditorGUI::SetCurrentObject;
		Bind["SetModuleSpace"] = &SceneEditorGUI::SetModuleSpace;
		Bind["SetNativeTechModule"] = &SceneEditorGUI::SetNativeTechModule;
		Bind["SetForeignCostMultiplier"] = &SceneEditorGUI::SetForeignCostMultiplier;
		Bind["TestBrainResidence"] = &SceneEditorGUI::TestBrainResidence;
		Bind["Update"] = &SceneEditorGUI::Update;//*/
	}

	{
		/*
		class_<Activity, Entity>("Activity")
			.enum_("ActivityState")
			[
				value("NOACTIVITY", -1),
				value("NOTSTARTED", 0),
				value("STARTING", 1),
				value("EDITING", 2),
				value("PREGAME", 3),
				value("RUNNING", 4),
				value("DEMOEND", 5),
				value("INERROR", 6),
				value("OVER", 7)
			]
			.enum_("Player")
			[
				value("NOPLAYER", -1),
				value("PLAYER_1", 0),
				value("PLAYER_2", 1),
				value("PLAYER_3", 2),
				value("PLAYER_4", 3),
				value("MAXPLAYERCOUNT", 4)
			]
			.enum_("Team")
			[
				value("NOTEAM", -1),
				value("TEAM_1", 0),
				value("TEAM_2", 1),
				value("TEAM_3", 2),
				value("TEAM_4", 3),
				value("MAXTEAMCOUNT", 4)
			]
			.enum_("ViewState")
			[
				value("NORMAL", 0),
				value("OBSERVE", 1),
				value("DEATHWATCH", 2),
				value("ACTORSELECT", 3),
				value("AISENTRYPOINT", 4),
				value("AIPATROLPOINTS", 5),
				value("AIGOLDDIGPOINT", 6),
				value("AIGOTOPOINT", 7),
				value("LZSELECT", 8)
			]
			.enum_("DifficultySetting")
			[
				value("MINDIFFICULTY", 0),
				value("CAKEDIFFICULTY", 15),
				value("EASYDIFFICULTY", 40),
				value("MEDIUMDIFFICULTY", 60),
				value("HARDDIFFICULTY", 85),
				value("NUTSDIFFICULTY", 98),
				value("MAXDIFFICULTY", 100),
				value("TESTDIFFICULTY", -1)
			]
			.enum_("AISkillSetting")
			[
				value("INFERIORSKILL", Activity::INFERIORSKILL),
				value("AVERAGESKILL", Activity::AVERAGESKILL),
				value("GOODSKILL", Activity::GOODSKILL),
				value("UNFAIRSKILL", Activity::UNFAIRSKILL),
				value("DEFAULTSKILL", Activity::DEFAULTSKILL)
			]
			.def(constructor<>())
			.property("ClassName", &Activity::GetClassName)
			.property("Description", &Activity::GetDescription)
			.property("InCampaignStage", &Activity::GetInCampaignStage, &Activity::SetInCampaignStage)
			.property("ActivityState", &Activity::GetActivityState, &Activity::SetActivityState)
			.property("SceneName", &Activity::GetSceneName, &Activity::SetSceneName)
			.property("PlayerCount", &Activity::GetPlayerCount, &Activity::SetPlayerCount)
			.def("DeactivatePlayer", &Activity::DeactivatePlayer)
			.def("PlayerActive", &Activity::PlayerActive)
			.def("PlayerHuman", &Activity::PlayerHuman)
			.property("HumanCount", &Activity::GetHumanCount)
			.property("TeamCount", &Activity::GetTeamCount, &Activity::SetTeamCount)
			.def("TeamActive", &Activity::TeamActive)
			.def("GetTeamOfPlayer", &Activity::GetTeamOfPlayer)
			.def("SetTeamOfPlayer", &Activity::SetTeamOfPlayer)
			.def("PlayersInTeamCount", &Activity::PlayersInTeamCount)
			.def("ScreenOfPlayer", &Activity::ScreenOfPlayer)
			.def("GetViewState", &Activity::GetViewState)
			.def("SetViewState", &Activity::SetViewState)
			.def("GetPlayerBrain", &Activity::GetPlayerBrain)
			.def("SetPlayerBrain", &Activity::SetPlayerBrain)
			.def("PlayerHadBrain", &Activity::PlayerHadBrain)
			.def("SetBrainEvacuated", &Activity::SetBrainEvacuated)
			.def("BrainWasEvacuated", &Activity::BrainWasEvacuated)
			.def("IsAssignedBrain", &Activity::IsAssignedBrain)
			.def("IsBrainOfWhichPlayer", &Activity::IsBrainOfWhichPlayer)
			.def("IsOtherPlayerBrain", &Activity::IsOtherPlayerBrain)
			.def("HumanBrainCount", &Activity::HumanBrainCount)
			.def("AIBrainCount", &Activity::AIBrainCount)
			.def("GetControlledActor", &Activity::GetControlledActor)
			.def("SetTeamFunds", &Activity::SetTeamFunds)
			.def("GetTeamFunds", &Activity::GetTeamFunds)
			.def("SetTeamAISkill", &Activity::SetTeamAISkill)
			.def("GetTeamAISkill", &Activity::GetTeamAISkill)
			.def("ChangeTeamFunds", &Activity::ChangeTeamFunds)
			.def("TeamFundsChanged", &Activity::TeamFundsChanged)
			.def("ReportDeath", &Activity::ReportDeath)
			.def("GetTeamDeathCount", &Activity::GetTeamDeathCount)
			.def("GetDemoTimeLeft", &Activity::GetDemoTimeLeft)
			.def("Running", &Activity::Running)
			.def("Paused", &Activity::Paused)
			.def("ActivityOver", &Activity::ActivityOver)
			.def("EnteredOrbit", &Activity::EnteredOrbit)
			.def("SwitchToActor", &Activity::SwitchToActor)
			.def("SwitchToNextActor", &Activity::SwitchToNextActor)
			.def("SwitchToPrevActor", &Activity::SwitchToPrevActor)
			.property("Difficulty", &Activity::GetDifficulty, &Activity::SetDifficulty)
			.def("IsPlayerTeam", &Activity::IsPlayerTeam)
			.def("ResetMessageTimer", &Activity::ResetMessageTimer),
		*/

		///////////////////////////////////////////////////////////////////////////

		sol::usertype<Activity> Bind = g_pSolLuaState->new_usertype<Activity>("Activity", sol::no_constructor);

		g_pSolLuaState->set("ActivityState", g_pSolLuaState->create_table_with(
			"NOACTIVITY", -1,
			"NOTSTARTED", 0,
			"STARTING", 1,
			"EDITING", 2,
			"PREGAME", 3,
			"RUNNING", 4,
			"DEMOEND", 5,
			"INERROR", 6,
			"OVER", 7
		));

		g_pSolLuaState->set("Player", g_pSolLuaState->create_table_with(
			"NOPLAYER", -1,
			"PLAYER_1", 0,
			"PLAYER_2", 1,
			"PLAYER_3", 2,
			"PLAYER_4", 3,
			"MAXPLAYERCOUNT", 4
		));

		g_pSolLuaState->set("Team", g_pSolLuaState->create_table_with(
			"NOTEAM", -1,
			"TEAM_1", 0,
			"TEAM_2", 1,
			"TEAM_3", 2,
			"TEAM_4", 3,
			"MAXTEAMCOUNT", 4
		));

		g_pSolLuaState->set("ViewState", g_pSolLuaState->create_table_with(
			"NORMAL", 0,
			"OBSERVE", 1,
			"DEATHWATCH", 2,
			"ACTORSELECT", 3,
			"AISENTRYPOINT", 4,
			"AIPATROLPOINTS", 5,
			"AIGOLDDIGPOINT", 6,
			"AIGOTOPOINT", 7,
			"LZSELECT", 8
		));

		g_pSolLuaState->set("DifficultySetting", g_pSolLuaState->create_table_with(
			"MINDIFFICULTY", 0,
			"CAKEDIFFICULTY", 15,
			"EASYDIFFICULTY", 40,
			"MEDIUMDIFFICULTY", 60,
			"HARDDIFFICULTY", 85,
			"NUTSDIFFICULTY", 98,
			"MAXDIFFICULTY", 100,
			"TESTDIFFICULTY", -1
		));

		g_pSolLuaState->set("AISkillSetting", g_pSolLuaState->create_table_with(
			"INFERIORSKILL", Activity::INFERIORSKILL,
			"AVERAGESKILL", Activity::AVERAGESKILL,
			"GOODSKILL", Activity::GOODSKILL,
			"UNFAIRSKILL", Activity::UNFAIRSKILL,
			"DEFAULTSKILL", Activity::DEFAULTSKILL
		));

		Bind["ClassName"] = sol::property(&Activity::GetClassName);
		Bind["Description"] = sol::property(&Activity::GetDescription);
		Bind["InCampaignStage"] = sol::property(&Activity::GetInCampaignStage, &Activity::SetInCampaignStage);
		Bind["ActivityState"] = sol::property(&Activity::GetActivityState, &Activity::SetActivityState);
		Bind["SceneName"] = sol::property(&Activity::GetSceneName, &Activity::SetSceneName);
		Bind["PlayerCount"] = sol::property(&Activity::GetPlayerCount, &Activity::SetPlayerCount);
		Bind["DeactivatePlayer"] = &Activity::DeactivatePlayer;
		Bind["PlayerActive"] = &Activity::PlayerActive;
		Bind["PlayerHuman"] = &Activity::PlayerHuman;
		Bind["HumanCount"] = sol::property(&Activity::GetHumanCount);
		Bind["TeamCount"] = sol::property(&Activity::GetTeamCount, &Activity::SetTeamCount);
		Bind["TeamActive"] = &Activity::TeamActive;
		Bind["GetTeamOfPlayer"] = &Activity::GetTeamOfPlayer;
		Bind["SetTeamOfPlayer"] = &Activity::SetTeamOfPlayer;
		Bind["PlayersInTeamCount"] = &Activity::PlayersInTeamCount;
		Bind["ScreenOfPlayer"] = &Activity::ScreenOfPlayer;
		Bind["GetViewState"] = &Activity::GetViewState;
		Bind["SetViewState"] = &Activity::SetViewState;
		Bind["GetPlayerBrain"] = &Activity::GetPlayerBrain;
		Bind["SetPlayerBrain"] = &Activity::SetPlayerBrain;
		Bind["PlayerHadBrain"] = &Activity::PlayerHadBrain;
		Bind["SetBrainEvacuated"] = &Activity::SetBrainEvacuated;
		Bind["BrainWasEvacuated"] = &Activity::BrainWasEvacuated;
		Bind["IsAssignedBrain"] = &Activity::IsAssignedBrain;
		Bind["IsBrainOfWhichPlayer"] = &Activity::IsBrainOfWhichPlayer;
		Bind["IsOtherPlayerBrain"] = &Activity::IsOtherPlayerBrain;
		Bind["HumanBrainCount"] = &Activity::HumanBrainCount;
		Bind["AIBrainCount"] = &Activity::AIBrainCount;
		Bind["GetControlledActor"] = &Activity::GetControlledActor;
		Bind["SetTeamFunds"] = &Activity::SetTeamFunds;
		Bind["GetTeamFunds"] = &Activity::GetTeamFunds;
		Bind["SetTeamAISkill"] = &Activity::SetTeamAISkill;
		Bind["GetTeamAISkill"] = &Activity::GetTeamAISkill;
		Bind["ChangeTeamFunds"] = &Activity::ChangeTeamFunds;
		Bind["TeamFundsChanged"] = &Activity::TeamFundsChanged;
		Bind["ReportDeath"] = &Activity::ReportDeath;
		Bind["GetTeamDeathCount"] = &Activity::GetTeamDeathCount;
		Bind["GetDemoTimeLeft"] = &Activity::GetDemoTimeLeft;
		Bind["Running"] = &Activity::Running;
		Bind["Paused"] = &Activity::Paused;
		Bind["ActivityOver"] = &Activity::ActivityOver;
		Bind["EnteredOrbit"] = &Activity::EnteredOrbit;
		Bind["SwitchToActor"] = &Activity::SwitchToActor;
		Bind["SwitchToNextActor"] = &Activity::SwitchToNextActor;
		Bind["SwitchToPrevActor"] = &Activity::SwitchToPrevActor;
		Bind["Difficulty"] = sol::property(&Activity::GetDifficulty, &Activity::SetDifficulty);
		Bind["IsPlayerTeam"] = &Activity::IsPlayerTeam;
		Bind["ResetMessageTimer"] = &Activity::ResetMessageTimer;//*/
	}

	{
		/*
		class_<GUIBanner>("GUIBanner")
			.enum_("AnimMode")
			[
				value("BLINKING", 0),
				value("FLYBYLEFTWARD", 1),
				value("FLYBYRIGHTWARD", 2),
				value("ANIMMODECOUNT", 3)
			]
			.enum_("AnimState")
			[
				value("NOTSTARTED", 0),
				value("SHOWING", 1),
				value("SHOW", 2),
				value("HIDING", 3),
				value("OVER", 4),
				value("ANIMSTATECOUNT", 5)
			]
			.enum_("BannerColor")
			[
				value("RED", 0),
				value("YELLOW", 1)
			]
			.property("BannerText", &GUIBanner::GetBannerText)
			.property("AnimState", &GUIBanner::GetAnimState)
			.def("IsVisible", &GUIBanner::IsVisible)
			.property("Kerning", &GUIBanner::GetKerning, &GUIBanner::SetKerning)
			.def("ShowText", &GUIBanner::ShowText)
			.def("HideText", &GUIBanner::HideText)
			.def("ClearText", &GUIBanner::ClearText),
		*/

		///////////////////////////////////////////////////////////////////////////

		sol::usertype<GUIBanner> Bind = g_pSolLuaState->new_usertype<GUIBanner>("GUIBanner", sol::no_constructor);

		g_pSolLuaState->set("AnimMode", g_pSolLuaState->create_table_with(
			"BLINKING", 0,
			"FLYBYLEFTWARD", 1,
			"FLYBYRIGHTWARD", 2,
			"ANIMMODECOUNT", 3
		));

		g_pSolLuaState->set("AnimState", g_pSolLuaState->create_table_with(
			"NOTSTARTED", 0,
			"SHOWING", 1,
			"SHOW", 2,
			"HIDING", 3,
			"OVER", 4,
			"ANIMSTATECOUNT", 5
		));

		g_pSolLuaState->set("BannerColor", g_pSolLuaState->create_table_with(
			"RED", 0,
			"YELLOW", 1
		));

		Bind["BannerText"] = sol::property(&GUIBanner::GetBannerText);
		Bind["AnimState"] = sol::property(&GUIBanner::GetAnimState);
		Bind["IsVisible"] = &GUIBanner::IsVisible;
		Bind["Kerning"] = sol::property(&GUIBanner::GetKerning, &GUIBanner::SetKerning);
		Bind["ShowText"] = &GUIBanner::ShowText;
		Bind["HideText"] = &GUIBanner::HideText;
		Bind["ClearText"] = &GUIBanner::ClearText;//*/
	}

	{
		/*
		def("ToGameActivity", (GameActivity *(*)(Entity *))&ToGameActivity),
		def("ToGameActivity", (const GameActivity *(*)(const Entity *))&ToConstGameActivity),
		class_<GameActivity, Activity>("GameActivity")
			.enum_("ObjectiveArrowDir")
			[
				value("ARROWDOWN", 0),
				value("ARROWLEFT", 1),
				value("ARROWRIGHT", 2),
				value("ARROWUP", 3)
			]
			.def(constructor<>())
			.def("SetObservationTarget", &GameActivity::SetObservationTarget)
			.def("SetDeathViewTarget", &GameActivity::SetDeathViewTarget)
			.def("SetLandingZone", &GameActivity::SetLandingZone)
			.def("GetLandingZone", &GameActivity::GetLandingZone)
			.def("SetActorSelectCursor", &GameActivity::SetActorSelectCursor)
			.def("GetBuyGUI", &GameActivity::GetBuyGUI)
			.def("GetEditorGUI", &GameActivity::GetEditorGUI)
			.property("WinnerTeam", &GameActivity::GetWinnerTeam, &GameActivity::SetWinnerTeam)
			.property("CPUTeam", &GameActivity::GetCPUTeam, &GameActivity::SetCPUTeam)
//            .def_readwrite("ActorCursor", &GameActivity::m_ActorCursor)
			.def_readwrite("CursorTimer", &GameActivity::m_CursorTimer)
			.def_readwrite("GameTimer", &GameActivity::m_GameTimer)
			.def_readwrite("GameOverTimer", &GameActivity::m_GameOverTimer)
			.def_readwrite("GameOverPeriod", &GameActivity::m_GameOverPeriod)
			.def_readwrite("OrbitedCraft", &GameActivity::m_pOrbitedCraft)
			.def_readwrite("PieMenuActor", &GameActivity::m_pPieMenuActor)
			.def("OtherTeam", &GameActivity::OtherTeam)
			.def("OneOrNoneTeamsLeft", &GameActivity::OneOrNoneTeamsLeft)
			.def("WhichTeamLeft", &GameActivity::WhichTeamLeft)
			.def("NoTeamLeft", &GameActivity::NoTeamLeft)
			// Backwards compat
			.def("OnlyOneTeamLeft", &GameActivity::OneOrNoneTeamsLeft)
			.def("GetBanner", &GameActivity::GetBanner)
			.def("SetLZArea", &GameActivity::SetLZArea)
			.def("GetLZArea", &GameActivity::GetLZArea)
			.def("SetBrainLZWidth", &GameActivity::SetBrainLZWidth)
			.def("GetBrainLZWidth", &GameActivity::GetBrainLZWidth)
			.def("GetActiveCPUTeamCount", &GameActivity::GetActiveCPUTeamCount)
			.def("GetActiveHumanTeamCount", &GameActivity::GetActiveHumanTeamCount)
			.def("AddObjectivePoint", &GameActivity::AddObjectivePoint)
			.def("YSortObjectivePoints", &GameActivity::YSortObjectivePoints)
			.def("ClearObjectivePoints", &GameActivity::ClearObjectivePoints)
			.def("AddOverridePurchase", &GameActivity::AddOverridePurchase)
			.def("SetOverridePurchaseList", (int (GameActivity::*)(const Loadout *, int))&GameActivity::SetOverridePurchaseList)
			.def("SetOverridePurchaseList", (int (GameActivity::*)(string, int))&GameActivity::SetOverridePurchaseList)
			.def("ClearOverridePurchase", &GameActivity::ClearOverridePurchase)
			.def("CreateDelivery", (bool (GameActivity::*)(int))&GameActivity::CreateDelivery)
			.def("CreateDelivery", (bool (GameActivity::*)(int, int))&GameActivity::CreateDelivery)
			.def("CreateDelivery", (bool (GameActivity::*)(int, int, Vector&))&GameActivity::CreateDelivery)
			.def("CreateDelivery", (bool (GameActivity::*)(int, int, Actor*))&GameActivity::CreateDelivery)
			.def("GetDeliveryCount", &GameActivity::GetDeliveryCount)
			.property("DeliveryDelay", &GameActivity::GetDeliveryDelay, &GameActivity::SetDeliveryDelay)
			.def("GetTeamTech", &GameActivity::GetTeamTech)
			.def("SetTeamTech", &GameActivity::SetTeamTech)
			.def("GetCrabToHumanSpawnRatio", &GameActivity::GetCrabToHumanSpawnRatio)
			.property("BuyMenuEnabled", &GameActivity::GetBuyMenuEnabled, &GameActivity::SetBuyMenuEnabled)
			.property("CraftsOrbitAtTheEdge", &GameActivity::GetCraftsOrbitAtTheEdge, &GameActivity::SetCraftsOrbitAtTheEdge)
			.def("TeamIsCPU", &GameActivity::TeamIsCPU)
			.def("GetStartingGold", &GameActivity::GetStartingGold)
			.def("GetFogOfWarEnabled", &GameActivity::GetFogOfWarEnabled)
			.def("UpdateEditing", &GameActivity::UpdateEditing)
			.def("DisableAIs", &GameActivity::DisableAIs)
			.def("InitAIs", &GameActivity::InitAIs)
			.def("AddPieMenuSlice", &GameActivity::AddPieMenuSlice)
			.def("AlterPieMenuSlice", &GameActivity::AlterPieMenuSlice)
			.def("RemovePieMenuSlice", &GameActivity::RemovePieMenuSlice)
			.def_readwrite("PieMenuSlices", &GameActivity::m_CurrentPieMenuSlices, luabind::return_stl_iterator()),
		*/

		//def("ToGameActivity", (GameActivity* (*)(Entity*))& ToGameActivity),
		//def("ToGameActivity", (const GameActivity* (*)(const Entity*))& ToConstGameActivity),

		///////////////////////////////////////////////////////////////////////////

		g_pSolLuaState->set("ToGameActivity", (GameActivity* (*)(Entity*))& ToGameActivity);
		g_pSolLuaState->set("ToGameActivity", (const GameActivity* (*)(const Entity*))& ToConstGameActivity);

		sol::usertype<GameActivity> Bind = g_pSolLuaState->new_usertype<GameActivity>("GameActivity", sol::no_constructor);
		g_pSolLuaState->set("ObjectiveArrowDir", g_pSolLuaState->create_table_with(
			"ARROWDOWN", 0,
			"ARROWLEFT", 1,
			"ARROWRIGHT", 2,
			"ARROWUP", 3
		));
		
		Bind["SetObservationTarget"] = &GameActivity::SetObservationTarget;
		Bind["SetDeathViewTarget"] = &GameActivity::SetDeathViewTarget;
		Bind["SetLandingZone"] = &GameActivity::SetLandingZone;
		Bind["GetLandingZone"] = &GameActivity::GetLandingZone;
		Bind["SetActorSelectCursor"] = &GameActivity::SetActorSelectCursor;
		Bind["GetBuyGUI"] = &GameActivity::GetBuyGUI;
		Bind["GetEditorGUI"] = &GameActivity::GetEditorGUI;
		Bind["WinnerTeam"] = sol::property(&GameActivity::GetWinnerTeam, &GameActivity::SetWinnerTeam);
		Bind["CPUTeam"] = sol::property(&GameActivity::GetCPUTeam, &GameActivity::SetCPUTeam);
		//            Bind["ActorCursor"] = &GameActivity::m_ActorCursor)
		Bind["CursorTimer"] = sol::property(&GameActivity::m_CursorTimer);
		Bind["GameTimer"] = sol::property(&GameActivity::m_GameTimer);
		Bind["GameOverTimer"] = sol::property(&GameActivity::m_GameOverTimer);
		Bind["GameOverPeriod"] = sol::property(&GameActivity::m_GameOverPeriod);
		Bind["OrbitedCraft"] = sol::property(&GameActivity::m_pOrbitedCraft);
		Bind["PieMenuActor"] = sol::property(&GameActivity::m_pPieMenuActor);
		Bind["OtherTeam"] = &GameActivity::OtherTeam;
		Bind["OneOrNoneTeamsLeft"] = &GameActivity::OneOrNoneTeamsLeft;
		Bind["WhichTeamLeft"] = &GameActivity::WhichTeamLeft;
		Bind["NoTeamLeft"] = &GameActivity::NoTeamLeft;
		// Backwards compat
		Bind["OnlyOneTeamLeft"] = &GameActivity::OneOrNoneTeamsLeft;
		Bind["GetBanner"] = &GameActivity::GetBanner;
		Bind["SetLZArea"] = &GameActivity::SetLZArea;
		Bind["GetLZArea"] = &GameActivity::GetLZArea;
		Bind["SetBrainLZWidth"] = &GameActivity::SetBrainLZWidth;
		Bind["GetBrainLZWidth"] = &GameActivity::GetBrainLZWidth;
		Bind["GetActiveCPUTeamCount"] = &GameActivity::GetActiveCPUTeamCount;
		Bind["GetActiveHumanTeamCount"] = &GameActivity::GetActiveHumanTeamCount;
		Bind["AddObjectivePoint"] = &GameActivity::AddObjectivePoint;
		Bind["YSortObjectivePoints"] = &GameActivity::YSortObjectivePoints;
		Bind["ClearObjectivePoints"] = &GameActivity::ClearObjectivePoints;
		Bind["AddOverridePurchase"] = &GameActivity::AddOverridePurchase;
		Bind["SetOverridePurchaseList"] = (int (GameActivity::*)(const Loadout*, int)) & GameActivity::SetOverridePurchaseList;
		Bind["SetOverridePurchaseList"] = (int (GameActivity::*)(string, int)) & GameActivity::SetOverridePurchaseList;
		Bind["ClearOverridePurchase"] = &GameActivity::ClearOverridePurchase;
		Bind["CreateDelivery"] = (bool (GameActivity::*)(int)) & GameActivity::CreateDelivery;
		Bind["CreateDelivery"] = (bool (GameActivity::*)(int, int)) & GameActivity::CreateDelivery;
		Bind["CreateDelivery"] = (bool (GameActivity::*)(int, int, Vector&)) & GameActivity::CreateDelivery;
		Bind["CreateDelivery"] = (bool (GameActivity::*)(int, int, Actor*)) & GameActivity::CreateDelivery;
		Bind["GetDeliveryCount"] = &GameActivity::GetDeliveryCount;
		Bind["DeliveryDelay"] = sol::property(&GameActivity::GetDeliveryDelay, &GameActivity::SetDeliveryDelay);
		Bind["GetTeamTech"] = &GameActivity::GetTeamTech;
		Bind["SetTeamTech"] = &GameActivity::SetTeamTech;
		Bind["GetCrabToHumanSpawnRatio"] = &GameActivity::GetCrabToHumanSpawnRatio;
		Bind["BuyMenuEnabled"] = sol::property(&GameActivity::GetBuyMenuEnabled, &GameActivity::SetBuyMenuEnabled);
		Bind["CraftsOrbitAtTheEdge"] = sol::property(&GameActivity::GetCraftsOrbitAtTheEdge, &GameActivity::SetCraftsOrbitAtTheEdge);
		Bind["TeamIsCPU"] = &GameActivity::TeamIsCPU;
		Bind["GetStartingGold"] = &GameActivity::GetStartingGold;
		Bind["GetFogOfWarEnabled"] = &GameActivity::GetFogOfWarEnabled;
		Bind["UpdateEditing"] = &GameActivity::UpdateEditing;
		Bind["DisableAIs"] = &GameActivity::DisableAIs;
		Bind["InitAIs"] = &GameActivity::InitAIs;
		Bind["AddPieMenuSlice"] = &GameActivity::AddPieMenuSlice;
		Bind["AlterPieMenuSlice"] = &GameActivity::AlterPieMenuSlice;
		Bind["RemovePieMenuSlice"] = &GameActivity::RemovePieMenuSlice;
		Bind["PieMenuSlices"] = sol::property(&GameActivity::m_CurrentPieMenuSlices);//*/
	}

	{
		/*
		class_<PieMenuGUI::Slice>("Slice")
			.enum_("Direction")
			[
				value("NONE", 0),
				value("UP", 1),
				value("RIGHT", 2),
				value("DOWN", 3),
				value("LEFT", 4)
			]

			.enum_("Type")
			[
				value("PSI_NONE", 0),
				value("PSI_PICKUP", 1),
				value("PSI_DROP", 2),
				value("PSI_NEXTITEM", 3),
				value("PSI_PREVITEM", 4),
				value("PSI_RELOAD", 5),
				value("PSI_BUYMENU", 6),
				value("PSI_STATS", 7),
				value("PSI_MINIMAP", 8),
				value("PSI_FORMSQUAD", 9),
				value("PSI_CEASEFIRE", 10),
				value("PSI_SENTRY", 11),
				value("PSI_PATROL", 12),
				value("PSI_BRAINHUNT", 13),
				value("PSI_GOLDDIG", 14),
				value("PSI_GOTO", 15),
				value("PSI_RETURN", 16),
				value("PSI_STAY", 17),
				value("PSI_DELIVER", 18),
				value("PSI_SCUTTLE", 19),
				value("PSI_DONE", 20),
				value("PSI_LOAD", 21),
				value("PSI_SAVE", 22),
				value("PSI_NEW", 23),
				value("PSI_PICK", 24),
				value("PSI_MOVE", 25),
				value("PSI_REMOVE", 26),
				value("PSI_INFRONT", 27),
				value("PSI_BEHIND", 28),
				value("PSI_ZOOMIN", 29),
				value("PSI_ZOOMOUT", 30),
				value("PSI_TEAM1", 31),
				value("PSI_TEAM2", 32),
				value("PSI_TEAM3", 33),
				value("PSI_TEAM4", 34),
				value("PSI_SCRIPTED", 35),
				value("PSI_COUNT", 36)
			]

			.def(constructor<>())
			.property("FunctionName", &PieMenuGUI::Slice::GetFunctionName)
			.property("Description", &PieMenuGUI::Slice::GetDescription)
			.property("Type", &PieMenuGUI::Slice::GetType)
			.property("Direction", &PieMenuGUI::Slice::GetDirection),
		*/

		///////////////////////////////////////////////////////////////////////////

		sol::usertype<PieMenuGUI::Slice> Bind = g_pSolLuaState->new_usertype<PieMenuGUI::Slice>("Slice", sol::no_constructor);
		g_pSolLuaState->set("Direction", g_pSolLuaState->create_table_with(
			"NONE", 0,
			"UP", 1,
			"RIGHT", 2,
			"DOWN", 3,
			"LEFT", 4
		));

		g_pSolLuaState->set("Type", g_pSolLuaState->create_table_with(
			"PSI_NONE", 0,
			"PSI_PICKUP", 1,
			"PSI_DROP", 2,
			"PSI_NEXTITEM", 3,
			"PSI_PREVITEM", 4,
			"PSI_RELOAD", 5,
			"PSI_BUYMENU", 6,
			"PSI_STATS", 7,
			"PSI_MINIMAP", 8,
			"PSI_FORMSQUAD", 9,
			"PSI_CEASEFIRE", 10,
			"PSI_SENTRY", 11,
			"PSI_PATROL", 12,
			"PSI_BRAINHUNT", 13,
			"PSI_GOLDDIG", 14,
			"PSI_GOTO", 15,
			"PSI_RETURN", 16,
			"PSI_STAY", 17,
			"PSI_DELIVER", 18,
			"PSI_SCUTTLE", 19,
			"PSI_DONE", 20,
			"PSI_LOAD", 21,
			"PSI_SAVE", 22,
			"PSI_NEW", 23,
			"PSI_PICK", 24,
			"PSI_MOVE", 25,
			"PSI_REMOVE", 26,
			"PSI_INFRONT", 27,
			"PSI_BEHIND", 28,
			"PSI_ZOOMIN", 29,
			"PSI_ZOOMOUT", 30,
			"PSI_TEAM1", 31,
			"PSI_TEAM2", 32,
			"PSI_TEAM3", 33,
			"PSI_TEAM4", 34,
			"PSI_SCRIPTED", 35,
			"PSI_COUNT", 36
		));

		Bind["FunctionName"] = sol::property(&PieMenuGUI::Slice::GetFunctionName);
		Bind["Description"] = sol::property(&PieMenuGUI::Slice::GetDescription);
		Bind["Type"] = sol::property(&PieMenuGUI::Slice::GetType);
		Bind["Direction"] = sol::property(&PieMenuGUI::Slice::GetDirection);//*/
	}

	{
		/*
		ABSTRACTLUABINDING(GlobalScript, Entity)
			.def_readwrite("OrbitedCraft", &GlobalScript::m_pOrbitedCraft)
			.def_readwrite("PieMenuActor", &GlobalScript::m_pPieMenuActor)
			.def("Deactivate", &GlobalScript::Deactivate),
		*/

		///////////////////////////////////////////////////////////////////////////

		ABSTRACTLUABINDING_SOL(GlobalScript, Entity);

		Bind["OrbitedCraft"] = sol::property(&GlobalScript::m_pOrbitedCraft);
		Bind["PieMenuActor"] = sol::property(&GlobalScript::m_pPieMenuActor);
		Bind["Deactivate"] = &GlobalScript::Deactivate;//*/
	}

	{
		/*
		class_<ActivityMan>("ActivityManager")
			.property("DefaultActivityType", &ActivityMan::GetDefaultActivityType, &ActivityMan::SetDefaultActivityType)
			.property("DefaultActivityName", &ActivityMan::GetDefaultActivityName, &ActivityMan::SetDefaultActivityName)
			// Transfers ownership of the Activity to start into the ActivityMan, adopts ownership (_1 is the this ptr)
			.def("SetStartActivity", &ActivityMan::SetStartActivity, luabind::adopt_policy<2>())
			.def("GetStartActivity", &ActivityMan::GetStartActivity)
			.def("GetActivity", &ActivityMan::GetActivity)
			// Transfers ownership of the Activity to start into the ActivityMan, adopts ownership (_1 is the this ptr)
			.def("StartActivity", (int (ActivityMan::*)(Activity *))&ActivityMan::StartActivity, luabind::adopt_policy<2>())
			.def("StartActivity", (int (ActivityMan::*)(string, string))&ActivityMan::StartActivity)
			.def("RestartActivity", &ActivityMan::RestartActivity)
			.def("PauseActivity", &ActivityMan::PauseActivity)
			.def("EndActivity", &ActivityMan::EndActivity)
			.def("ActivityRunning", &ActivityMan::ActivityRunning)
			.def("ActivityPaused", &ActivityMan::ActivityPaused),
		*/

		///////////////////////////////////////////////////////////////////////////

		sol::usertype<ActivityMan> Bind = g_pSolLuaState->new_usertype<ActivityMan>("ActivityManager", sol::no_constructor);

		Bind["DefaultActivityType"] = sol::property(&ActivityMan::GetDefaultActivityType, &ActivityMan::SetDefaultActivityType);
		Bind["DefaultActivityName"] = sol::property(&ActivityMan::GetDefaultActivityName, &ActivityMan::SetDefaultActivityName);
		// Transfers ownership of the Activity to start into the ActivityMan, adopts ownership (_1 is the this ptr)
		Bind["SetStartActivity"] = &ActivityMan::SetStartActivity;
		Bind["GetStartActivity"] = &ActivityMan::GetStartActivity;
		Bind["GetActivity"] = &ActivityMan::GetActivity;
		// Transfers ownership of the Activity to start into the ActivityMan, adopts ownership (_1 is the this ptr;
		Bind["StartActivity"] = (int (ActivityMan::*)(Activity*)) & ActivityMan::StartActivity;
		Bind["StartActivity"] = (int (ActivityMan::*)(string, string)) & ActivityMan::StartActivity;
		Bind["RestartActivity"] = &ActivityMan::RestartActivity;
		Bind["PauseActivity"] = &ActivityMan::PauseActivity;
		Bind["EndActivity"] = &ActivityMan::EndActivity;
		Bind["ActivityRunning"] = &ActivityMan::ActivityRunning;
		Bind["ActivityPaused"] = &ActivityMan::ActivityPaused;//*/
	}

	{
		/*
		class_<MetaPlayer>("MetaPlayer")
			.def(constructor<>())
			.property("NativeTechModule", &MetaPlayer::GetNativeTechModule)
			.property("ForeignCostMultiplier", &MetaPlayer::GetForeignCostMultiplier)
			.property("NativeCostMultiplier", &MetaPlayer::GetNativeCostMultiplier)
			.property("InGamePlayer", &MetaPlayer::GetInGamePlayer)
			.property("BrainPoolCount", &MetaPlayer::GetBrainPoolCount, &MetaPlayer::SetBrainPoolCount)
			.def("ChangeBrainPoolCount", &MetaPlayer::ChangeBrainPoolCount),
		*/

		sol::usertype<MetaPlayer> Bind = g_pSolLuaState->new_usertype<MetaPlayer>("MetaPlayer", sol::no_constructor);

		Bind["NativeTechModule"] = sol::property(&MetaPlayer::GetNativeTechModule);
		Bind["ForeignCostMultiplier"] = sol::property(&MetaPlayer::GetForeignCostMultiplier);
		Bind["NativeCostMultiplier"] = sol::property(&MetaPlayer::GetNativeCostMultiplier);
		Bind["InGamePlayer"] = sol::property(&MetaPlayer::GetInGamePlayer);
		Bind["BrainPoolCount"] = sol::property(&MetaPlayer::GetBrainPoolCount, &MetaPlayer::SetBrainPoolCount);
		Bind["ChangeBrainPoolCount"] = &MetaPlayer::ChangeBrainPoolCount;//*/
	}

	{
		/*
		class_<MetaMan>("MetaManager")
			.property("GameName", &MetaMan::GetGameName, &MetaMan::SetGameName)
//            .property("GUI", &MetaMan::GetGUI)
			.property("PlayerTurn", &MetaMan::GetPlayerTurn)
			.property("PlayerCount", &MetaMan::GetPlayerCount)
			.def("GetTeamOfPlayer", &MetaMan::GetTeamOfPlayer)
			.def("GetPlayer", &MetaMan::GetPlayer)
			.def("GetMetaPlayerOfInGamePlayer", &MetaMan::GetMetaPlayerOfInGamePlayer)
			.def_readwrite("Players", &MetaMan::m_Players, luabind::return_stl_iterator()),
		*/

		///////////////////////////////////////////////////////////////////////////

		sol::usertype<MetaMan> Bind = g_pSolLuaState->new_usertype<MetaMan>("MetaManager", sol::no_constructor);

		Bind["GameName"] = sol::property(&MetaMan::GetGameName, &MetaMan::SetGameName);
		//	Bind["GUI", &MetaMan::GetGUI)
		Bind["PlayerTurn"] = sol::property(&MetaMan::GetPlayerTurn);
		Bind["PlayerCount"] = sol::property(&MetaMan::GetPlayerCount);
		Bind["GetTeamOfPlayer"] = &MetaMan::GetTeamOfPlayer;
		Bind["GetPlayer"] = &MetaMan::GetPlayer;
		Bind["GetMetaPlayerOfInGamePlayer"] = &MetaMan::GetMetaPlayerOfInGamePlayer;
		Bind["Players"] = sol::property(&MetaMan::m_Players);//*/
	}

	{
		/*
		class_<AlarmEvent>("AlarmEvent")
			.def(constructor<>())
			.def(constructor<const Vector &, int, float>())
			.def_readwrite("ScenePos", &AlarmEvent::m_ScenePos)
			.def_readwrite("Team", &AlarmEvent::m_Team)
			.def_readwrite("Range", &AlarmEvent::m_Range),
		*/

		///////////////////////////////////////////////////////////////////////////

		sol::usertype<AlarmEvent> Bind = g_pSolLuaState->new_usertype<AlarmEvent>("AlarmEvent", sol::no_constructor);

		Bind["ScenePos"] = sol::property(&AlarmEvent::m_ScenePos);
		Bind["Team"] = sol::property(&AlarmEvent::m_Team);
		Bind["Range"] = sol::property(&AlarmEvent::m_Range);//*/
	}

	{
		/*

		class_<MovableMan>("MovableManager")
			.def("GetMOFromID", &MovableMan::GetMOFromID)
			.def("FindObjectByUniqueID", &MovableMan::FindObjectByUniqueID)
			.def("GetMOIDCount", &MovableMan::GetMOIDCount)
			.def("GetTeamMOIDCount", &MovableMan::GetTeamMOIDCount)
			.def("PurgeAllMOs", &MovableMan::PurgeAllMOs)
			.def("GetNextActorInGroup", &MovableMan::GetNextActorInGroup)
			.def("GetPrevActorInGroup", &MovableMan::GetPrevActorInGroup)
			.def("GetNextTeamActor", &MovableMan::GetNextTeamActor)
			.def("GetPrevTeamActor", &MovableMan::GetPrevTeamActor)
//            .def("GetClosestTeamActor", (Actor * (MovableMan::*)(int , int , const Vector &, int , float *, const Actor *))&MovableMan::GetClosestTeamActor)
			.def("GetClosestEnemyActor", &MovableMan::GetClosestEnemyActor)
			.def("GetFirstTeamActor", &MovableMan::GetFirstTeamActor)
//			.def("GetClosestActor", (Actor * (MovableMan::*)(Vector &, int, float *, const Actor *))&MovableMan::GetClosestActor)
			.def("GetClosestBrainActor", &MovableMan::GetClosestBrainActor)
			.def("GetFirstBrainActor", &MovableMan::GetFirstBrainActor)
			.def("GetClosestOtherBrainActor", &MovableMan::GetClosestOtherBrainActor)
			.def("GetFirstOtherBrainActor", &MovableMan::GetFirstOtherBrainActor)
			.def("GetUnassignedBrain", &MovableMan::GetUnassignedBrain)
			.def("GetParticleCount", &MovableMan::GetParticleCount)
			.def("GetAGResolution", &MovableMan::GetAGResolution)
			.def("GetSplashRatio", &MovableMan::GetSplashRatio)
			.property("MaxDroppedItems", &MovableMan::GetMaxDroppedItems, &MovableMan::SetMaxDroppedItems)
			.property("ScriptedEntity", &MovableMan::GetScriptedEntity, &MovableMan::SetScriptedEntity)
			.def("SortTeamRoster", &MovableMan::SortTeamRoster)
			.def("ChangeActorTeam", &MovableMan::ChangeActorTeam)
			.def("AddMO", &AddMO, luabind::adopt_policy<2>())
			.def("AddActor", &AddActor, luabind::adopt_policy<2>())
			.def("AddItem", &AddItem, luabind::adopt_policy<2>())
			.def("AddParticle", &AddParticle, luabind::adopt_policy<2>())
			.def("RemoveActor", &MovableMan::RemoveActor)
			.def("RemoveItem", &MovableMan::RemoveItem)
			.def("RemoveParticle", &MovableMan::RemoveParticle)
			.def("ValidMO", &MovableMan::ValidMO)
			.def("IsActor", &MovableMan::IsActor)
			.def("IsDevice", &MovableMan::IsDevice)
			.def("IsParticle", &MovableMan::IsParticle)
			.def("IsOfActor", &MovableMan::IsOfActor)
			.def("GetRootMOID", &MovableMan::GetRootMOID)
			.def("RemoveMO", &MovableMan::RemoveMO)
			.def("KillAllActors", &MovableMan::KillAllActors)
			.def("OpenAllDoors", &MovableMan::OpenAllDoors)
			.def("IsParticleSettlingEnabled", &MovableMan::IsParticleSettlingEnabled)
			.def("EnableParticleSettling", &MovableMan::EnableParticleSettling)
			.def("IsMOSubtractionEnabled", &MovableMan::IsMOSubtractionEnabled)
			.def_readwrite("Actors", &MovableMan::m_Actors, luabind::return_stl_iterator())
			.def_readwrite("Items", &MovableMan::m_Items, luabind::return_stl_iterator())
			.def_readwrite("Particles", &MovableMan::m_Particles, luabind::return_stl_iterator())
			.def_readwrite("AddedActors", &MovableMan::m_AddedActors, luabind::return_stl_iterator())
			.def_readwrite("AddedItems", &MovableMan::m_AddedItems, luabind::return_stl_iterator())
			.def_readwrite("AddedParticles", &MovableMan::m_AddedParticles, luabind::return_stl_iterator())
			.def_readwrite("AlarmEvents", &MovableMan::m_AlarmEvents, luabind::return_stl_iterator())
			.def_readwrite("AddedAlarmEvents", &MovableMan::m_AddedAlarmEvents, luabind::return_stl_iterator()),
		*/

		///////////////////////////////////////////////////////////////////////////

		sol::usertype<MovableMan> Bind = g_pSolLuaState->new_usertype<MovableMan>("MovableManager", sol::no_constructor);

		Bind["GetMOFromID"] = &MovableMan::GetMOFromID;
		Bind["FindObjectByUniqueID"] = &MovableMan::FindObjectByUniqueID;
		Bind["GetMOIDCount"] = &MovableMan::GetMOIDCount;
		Bind["GetTeamMOIDCount"] = &MovableMan::GetTeamMOIDCount;
		Bind["PurgeAllMOs"] = &MovableMan::PurgeAllMOs;
		Bind["GetNextActorInGroup"] = &MovableMan::GetNextActorInGroup;
		Bind["GetPrevActorInGroup"] = &MovableMan::GetPrevActorInGroup;
		Bind["GetNextTeamActor"] = &MovableMan::GetNextTeamActor;
		Bind["GetPrevTeamActor"] = &MovableMan::GetPrevTeamActor;
		// Bind["GetClosestTeamActor"] = (Actor * (MovableMan::*;(int , int , const Vector &, int , float *, const Actor *;;&MovableMan::GetClosestTeamActor;
		Bind["GetClosestEnemyActor"] = &MovableMan::GetClosestEnemyActor;
		Bind["GetFirstTeamActor"] = &MovableMan::GetFirstTeamActor;
		// Bind["GetClosestActor"] = (Actor * (MovableMan::*;(Vector &, int, float *, const Actor *;;&MovableMan::GetClosestActor;
		Bind["GetClosestBrainActor"] = &MovableMan::GetClosestBrainActor;
		Bind["GetFirstBrainActor"] = &MovableMan::GetFirstBrainActor;
		Bind["GetClosestOtherBrainActor"] = &MovableMan::GetClosestOtherBrainActor;
		Bind["GetFirstOtherBrainActor"] = &MovableMan::GetFirstOtherBrainActor;
		Bind["GetUnassignedBrain"] = &MovableMan::GetUnassignedBrain;
		Bind["GetParticleCount"] = &MovableMan::GetParticleCount;
		Bind["GetAGResolution"] = &MovableMan::GetAGResolution;
		Bind["GetSplashRatio"] = &MovableMan::GetSplashRatio;
		Bind["MaxDroppedItems"] = sol::property(&MovableMan::GetMaxDroppedItems, &MovableMan::SetMaxDroppedItems);
		Bind["ScriptedEntity"] = sol::property(&MovableMan::GetScriptedEntity, &MovableMan::SetScriptedEntity);
		Bind["SortTeamRoster"] = &MovableMan::SortTeamRoster;
		Bind["ChangeActorTeam"] = &MovableMan::ChangeActorTeam;
		Bind["AddMO"] = &MovableMan::AddMO;
		Bind["AddActor"] = &MovableMan::AddActor;
		Bind["AddItem"] = &MovableMan::AddItem;
		Bind["AddParticle"] = &MovableMan::AddParticle;
		Bind["RemoveActor"] = &MovableMan::RemoveActor;
		Bind["RemoveItem"] = &MovableMan::RemoveItem;
		Bind["RemoveParticle"] = &MovableMan::RemoveParticle;
		Bind["ValidMO"] = &MovableMan::ValidMO;
		Bind["IsActor"] = &MovableMan::IsActor;
		Bind["IsDevice"] = &MovableMan::IsDevice;
		Bind["IsParticle"] = &MovableMan::IsParticle;
		Bind["IsOfActor"] = &MovableMan::IsOfActor;
		Bind["GetRootMOID"] = &MovableMan::GetRootMOID;
		Bind["RemoveMO"] = &MovableMan::RemoveMO;
		Bind["KillAllActors"] = &MovableMan::KillAllActors;
		Bind["OpenAllDoors"] = &MovableMan::OpenAllDoors;
		Bind["IsParticleSettlingEnabled"] = &MovableMan::IsParticleSettlingEnabled;
		Bind["EnableParticleSettling"] = &MovableMan::EnableParticleSettling;
		Bind["IsMOSubtractionEnabled"] = &MovableMan::IsMOSubtractionEnabled;
		Bind["Actors"] = sol::property(&MovableMan::m_Actors);
		Bind["Items"] = sol::property(&MovableMan::m_Items);
		Bind["Particles"] = sol::property(&MovableMan::m_Particles);
		Bind["AddedActors"] = sol::property(&MovableMan::m_AddedActors);
		Bind["AddedItems"] = sol::property(&MovableMan::m_AddedItems);
		Bind["AddedParticles"] = sol::property(&MovableMan::m_AddedParticles);
		Bind["AlarmEvents"] = sol::property(&MovableMan::m_AlarmEvents);
		Bind["AddedAlarmEvents"] = sol::property(&MovableMan::m_AddedAlarmEvents);//*/
	}

	{
		/*
		class_<ConsoleMan>("ConsoleManager")
			.def("PrintString", &ConsoleMan::PrintString)
			.def("SaveInputLog", &ConsoleMan::SaveInputLog)
			.def("SaveAllText", &ConsoleMan::SaveAllText)
			.def("Clear", &ConsoleMan::ClearLog)
			.property("ForceVisibility", &ConsoleMan::IsForceVisible, &ConsoleMan::ForceVisibility)
			.property("ScreenSize", &ConsoleMan::GetConsoleScreenSize, &ConsoleMan::SetConsoleScreenSize),
		*/

		///////////////////////////////////////////////////////////////////////////

		sol::usertype<ConsoleMan> Bind = g_pSolLuaState->new_usertype<ConsoleMan>("ConsoleManager", sol::no_constructor);

		Bind["PrintString"] = &ConsoleMan::PrintString;
		Bind["SaveInputLog"] = &ConsoleMan::SaveInputLog;
		Bind["SaveAllText"] = &ConsoleMan::SaveAllText;
		Bind["Clear"] = &ConsoleMan::ClearLog;
		Bind["ForceVisibility"] = sol::property(&ConsoleMan::IsForceVisible, &ConsoleMan::ForceVisibility);
		Bind["ScreenSize"] = sol::property(&ConsoleMan::GetConsoleScreenSize, &ConsoleMan::SetConsoleScreenSize);//*/
	}

	{
		/*
		class_<LuaMan>("LuaManager")
			Bind["TempEntity", &LuaMan::GetTempEntity, &LuaMan::SetTempEntity)
			.def("FileOpen", &LuaMan::FileOpen)
			.def("FileClose", &LuaMan::FileClose)
			.def("FileReadLine", &LuaMan::FileReadLine)
			.def("FileWriteLine", &LuaMan::FileWriteLine)
			.def("FileEOF", &LuaMan::FileEOF),
		*/

		///////////////////////////////////////////////////////////////////////////

		sol::usertype<LuaMan> Bind = g_pSolLuaState->new_usertype<LuaMan>("LuaManager", sol::no_constructor);

		Bind["TempEntity"] = sol::property(&LuaMan::GetTempEntity, &LuaMan::SetTempEntity);
		Bind["FileOpen"] = &LuaMan::FileOpen;
		Bind["FileClose"] = &LuaMan::FileClose;
		Bind["FileReadLine"] = &LuaMan::FileReadLine;
		Bind["FileWriteLine"] = &LuaMan::FileWriteLine;
		Bind["FileEOF"] = &LuaMan::FileEOF;//*/
	}

	{
		/*
		class_<SettingsMan>("SettingsdManager")
			Bind["PrintDebugInfo", &SettingsMan::PrintDebugInfo, &SettingsMan::SetPrintDebugInfo)
			Bind["RecommendedMOIDCount", &SettingsMan::RecommendedMOIDCount),
		*/

		///////////////////////////////////////////////////////////////////////////

		sol::usertype<SettingsMan> Bind = g_pSolLuaState->new_usertype<SettingsMan>("SettingsManager", sol::no_constructor);

		Bind["PrintDebugInfo"] = sol::property(&SettingsMan::PrintDebugInfo, &SettingsMan::SetPrintDebugInfo);
		Bind["RecommendedMOIDCount"] = sol::property(&SettingsMan::RecommendedMOIDCount);//*/
	}


	{
		/*
		// NOT a member function, so adopting _1 instead of the _2 for the first param, since there's no "this" pointer!!
		def("DeleteEntity", &DeleteEntity, luabind::adopt_policy<1>()),
		def("PosRand", &PosRand),
		def("NormalRand", &NormalRand),
		def("RangeRand", &RangeRand),
		def("SelectRand", &SelectRand),
		def("LERP", &LERP),
		def("EaseIn", &EaseIn),
		def("EaseOut", &EaseOut),
		def("EaseInOut", &EaseInOut),
		def("Clamp", &Limit)
		*/

		g_pSolLuaState->set("DeleteEntity", &DeleteEntity);
		g_pSolLuaState->set("PosRand", &PosRand);
		g_pSolLuaState->set("NormalRand", &NormalRand);
		g_pSolLuaState->set("RangeRand", &RangeRand);
		g_pSolLuaState->set("SelectRand", &SelectRand);
		g_pSolLuaState->set("LERP", &LERP);
		g_pSolLuaState->set("EaseIn", &EaseIn);
		g_pSolLuaState->set("EaseOut", &EaseOut);
		g_pSolLuaState->set("EaseInOut", &EaseInOut);
		g_pSolLuaState->set("Clamp", &Limit);//*/
	}

    // Declare all useful classes in the master state
    //module(m_pMasterState)
    //[
    //];

    // Assign the manager instances to globals in the lua master state
    //globals(m_pMasterState)["TimerMan"] = &g_TimerMan;
    //globals(m_pMasterState)["FrameMan"] = &g_FrameMan;
    //globals(m_pMasterState)["PresetMan"] = &g_PresetMan;
    //globals(m_pMasterState)["AudioMan"] = &g_AudioMan;
    //globals(m_pMasterState)["UInputMan"] = &g_UInputMan;
    //globals(m_pMasterState)["SceneMan"] = &g_SceneMan;
    //globals(m_pMasterState)["ActivityMan"] = &g_ActivityMan;
    //globals(m_pMasterState)["MetaMan"] = &g_MetaMan;
    //globals(m_pMasterState)["MovableMan"] = &g_MovableMan;
    //globals(m_pMasterState)["ConsoleMan"] = &g_ConsoleMan;
    //globals(m_pMasterState)["LuaMan"] = &g_LuaMan;
    //globals(m_pMasterState)["SettingsMan"] = &g_SettingsMan;

	g_pSolLuaState->set("TimerMan", &g_TimerMan);
	g_pSolLuaState->set("FrameMan", &g_FrameMan);
	g_pSolLuaState->set("PresetMan", &g_PresetMan);
	g_pSolLuaState->set("AudioMan", &g_AudioMan);
	g_pSolLuaState->set("UInputMan", &g_UInputMan);
	g_pSolLuaState->set("SceneMan", &g_SceneMan);
	g_pSolLuaState->set("ActivityMan", &g_ActivityMan);
	g_pSolLuaState->set("MetaMan", &g_MetaMan);
	g_pSolLuaState->set("MovableMan", &g_MovableMan);
	g_pSolLuaState->set("ConsoleMan", &g_ConsoleMan);
	g_pSolLuaState->set("LuaMan", &g_LuaMan);
	g_pSolLuaState->set("SettingsMan", &g_SettingsMan);




    luaL_dostring(m_pMasterState,
        // Override print() in the lua state to output to the console
        "print = function(toPrint) ConsoleMan:PrintString(\"PRINT: \" .. tostring(toPrint)); end;\n"
        // Add cls() as a shorcut to ConsoleMan:Clear()
        "cls = function() ConsoleMan:Clear(); end;"
        // Add package path to the defaults
        "package.path = package.path .. \";Base.rte/?.lua\";\n"
    );

    return 0;
}

void LuaMan::ClearUserModuleCache()
{
	luaL_dostring(m_pMasterState, "for m, n in pairs(package.loaded) do if type(n) == \"boolean\" then package.loaded[m] = nil end end");
}

/*
//////////////////////////////////////////////////////////////////////////////////////////
// Virtual method:  ReadProperty
//////////////////////////////////////////////////////////////////////////////////////////
// Description:     Reads a property value from a reader stream. If the name isn't
//                  recognized by this class, then ReadProperty of the parent class
//                  is called. If the property isn't recognized by any of the base classes,
//                  false is returned, and the reader's position is untouched.

int LuaMan::ReadProperty(std::string propName, Reader &reader)
{
//    if (propName == "AddEffect")
//        g_PresetMan.GetEntityPreset(reader);
//    else
        // See if the base class(es) can find a match instead
        return Serializable::ReadProperty(propName, reader);

    return 0;
}


//////////////////////////////////////////////////////////////////////////////////////////
// Virtual method:  Save
//////////////////////////////////////////////////////////////////////////////////////////
// Description:     Saves the complete state of this LuaMan with a Writer for
//                  later recreation with Create(Reader &reader);

int LuaMan::Save(Writer &writer) const
{

// TODO: "Do this!")

    return 0;
}
*/

//////////////////////////////////////////////////////////////////////////////////////////
// Method:          Destroy
//////////////////////////////////////////////////////////////////////////////////////////
// Description:     Destroys and resets (through Clear()) the LuaMan object.

void LuaMan::Destroy()
{
    lua_close(m_pMasterState);

	//Close all opened files
	for (int i = 0; i < MAX_OPEN_FILES; ++i)
		FileClose(i);

    Clear();
}


//////////////////////////////////////////////////////////////////////////////////////////
// Method:          SavePointerAsGlobal
//////////////////////////////////////////////////////////////////////////////////////////
// Description:     Takes a pointer to an object and saves it in the Lua state as a global
//                  of a specified variable name.

int LuaMan::SavePointerAsGlobal(void *pToSave, string globalName)
{
    // Push the pointer onto the Lua stack
    lua_pushlightuserdata(m_pMasterState, pToSave);
    // Pop and assign that pointer to a global var in the Lua state
    lua_setglobal(m_pMasterState, globalName.c_str());

    return 0;
}


//////////////////////////////////////////////////////////////////////////////////////////
// Method:          GlobalIsDefined
//////////////////////////////////////////////////////////////////////////////////////////
// Description:     Checks if there is anything defined on a specific global var in Lua.

bool LuaMan::GlobalIsDefined(string globalName)
{
    // Get the var you want onto the stack so we can check it
    lua_getglobal(m_pMasterState, globalName.c_str());
    // Now report if it is nil/null or not
    bool isDefined = !lua_isnil(m_pMasterState, -1);
    // Pop the var so this operation is balanced and leaves the stack as it was
    lua_pop(m_pMasterState, 1);

    return isDefined;
}


//////////////////////////////////////////////////////////////////////////////////////////
// Method:          TableEntryIsDefined
//////////////////////////////////////////////////////////////////////////////////////////
// Description:     Checks if there is anything defined in a specific index of a table.

bool LuaMan::TableEntryIsDefined(string tableName, string indexName)
{
    // Push the table onto the stack, checking if it even exists
    lua_getglobal(m_pMasterState, tableName.c_str());
    if (!lua_istable(m_pMasterState, -1))
    {
//        error(m_pMasterState, tableName + " is not a table when checking for the " + indexName + " within it.");
        // Clean up and report that there was nothing properly defined here
        lua_pop(m_pMasterState, 1);
        return false;
    }

    // Push the value at the requested index onto the stack so we can check if it's anything
    lua_getfield(m_pMasterState, -1, indexName.c_str());
    // Now report if it is nil/null or not
    bool isDefined = !lua_isnil(m_pMasterState, -1);
    // Pop both the var and the table so this operation is balanced and leaves the stack as it was
    lua_pop(m_pMasterState, 2);

    return isDefined;
}


//////////////////////////////////////////////////////////////////////////////////////////
// Method:          ExpressionIsTrue
//////////////////////////////////////////////////////////////////////////////////////////
// Description:     Gets the result of an arbirary expression in lua as evaluating to
//                  true or false.

bool LuaMan::ExpressionIsTrue(string expression, bool consoleErrors)
{
    if (expression.empty())
        return false;

    bool result = false;

    try
    {
        // Push the script string onto the stack so we can execute it, and then actually try to run it
        // Assign the result to a dedicated temp global variable
        if (luaL_dostring(m_pMasterState, (string("ExpressionResult = ") + expression + string(";")).c_str()))
        {
            // Retrieve and pop the error message off the stack
            m_LastError = string("When evaluating Lua expression: ") + lua_tostring(m_pMasterState, -1);
            lua_pop(m_pMasterState, 1);
            if (consoleErrors)
            {
                g_ConsoleMan.PrintString("ERROR: " + m_LastError);
                ClearErrors();
            }
            return false;
        }
    }
    catch(const std::exception &e)
    {
        m_LastError = string("When evaluating Lua expression: ") + e.what();
        if (consoleErrors)
        {
            g_ConsoleMan.PrintString("ERROR: " + m_LastError);
            ClearErrors();
        }
        return false;
    }

    // Get the result var onto the stack so we can check it
    lua_getglobal(m_pMasterState, "ExpressionResult");
    // Now report if it is nil/null or not
    result = lua_toboolean(m_pMasterState, -1);
    // Pop the result var so this operation is balanced and leaves the stack as it was
    lua_pop(m_pMasterState, 1);

    return result;
}


//////////////////////////////////////////////////////////////////////////////////////////
// Method:          RunScriptString
//////////////////////////////////////////////////////////////////////////////////////////
// Description:     Takes a string containing a script snippet and runs it on the master
//                  state.

int LuaMan::RunScriptString(string scriptString, bool consoleErrors)
{
    SLICK_PROFILE(0xFF124325);

    if (scriptString.empty())
        return -1;

    int error = 0;

    // Push the fancier error handler so pcall can use it if things go awry
//    lua_pushcfunction(m_pMasterState, &AddFileAndLineToError);

    try
    {
        // Push the script string onto the stack so we can execute it, and then actually try to run it
//        // Point out the special error handling function on the stack, which is one under the file's position on the stack (-2)
//        if (luaL_loadstring(m_pMasterState, scriptString.c_str()) || lua_pcall(m_pMasterState, 0, LUA_MULTRET, -2))
        if (luaL_dostring(m_pMasterState, scriptString.c_str()))
        {
            // Retrieve and pop the error message off the stack
			//m_LastError = _AddFileAndLineToError(m_pMasterState, m_LastError);
			m_LastError = lua_tostring(m_pMasterState, -1);
            lua_pop(m_pMasterState, 1);
            if (consoleErrors)
            {
                g_ConsoleMan.PrintString("ERROR: " + m_LastError);
                ClearErrors();
            }
            error = -1;
        }
    }
    catch(const std::exception &e)
    {
        m_LastError = e.what();
        if (consoleErrors)
        {
            g_ConsoleMan.PrintString("ERROR: " + m_LastError);
            ClearErrors();
        }
        error = -1;
    }

    // Pop the custom error function off
//    lua_pop(m_pMasterState, 1);
        
    return error;
}


//////////////////////////////////////////////////////////////////////////////////////////
// Method:          RunScriptFile
//////////////////////////////////////////////////////////////////////////////////////////
// Description:     Opens and loads a file containing a script and runs it on the master
//                  state.

int LuaMan::RunScriptFile(string filePath, bool consoleErrors)
{
//    if (filePath.empty())
//        return -1;
//     m_LastError = "Can't open from empty filepath!"
    int error = 0;

    // Push the fancier error handler so pcall can use it if things go awry
//    lua_pushcfunction(m_pMasterState, &AddFileAndLineToError);

    try
    {
        // Push the script file's contents onto the stack so we can execute it, and then actually try to run it
//        // Point out the special error handling function on the stack, which is one under the file's position on the stack (-2)
//        if (luaL_loadfile(m_pMasterState, filePath.c_str()) || lua_pcall(m_pMasterState, 0, LUA_MULTRET, -2))
	const char *path = filePath.c_str();
#ifndef WIN32
	extern char *fcase( const char *path );
	char *fixed = fcase( filePath.c_str() );
	if ( fixed )
	{
		path = fixed;
	}
#endif
        if (luaL_dofile(m_pMasterState, path))
        {
            // Retrieve and pop the error message off the stack
            m_LastError = lua_tostring(m_pMasterState, -1);
            lua_pop(m_pMasterState, 1);
            if (consoleErrors)
            {
                g_ConsoleMan.PrintString("ERROR: " + m_LastError);
                ClearErrors();
            }
            error = -1;
        }
    }
    catch(const std::exception &e)
    {
        m_LastError = e.what();
        if (consoleErrors)
        {
            g_ConsoleMan.PrintString("ERROR: " + m_LastError);
            ClearErrors();
        }
        error = -1;
    }

    // Pop the custom error function off
//    lua_pop(m_pMasterState, 1);

    return error;
}


//////////////////////////////////////////////////////////////////////////////////////////
// Method:          GetNewPresetID
//////////////////////////////////////////////////////////////////////////////////////////
// Description:     Returns an ID string unique to this runtime for use by original presets
//                  that have scripts associated with them.

string LuaMan::GetNewPresetID()
{
    // Generate the new ID
    char newID[64];
    sprintf(newID, "Pre%05i", m_NextPresetID);
    // Increment the ID so it will be diff for the next one (improve this primitive approach??)
    m_NextPresetID++;

    return string(newID);
}


//////////////////////////////////////////////////////////////////////////////////////////
// Method:          GetNewObjectID
//////////////////////////////////////////////////////////////////////////////////////////
// Description:     Returns an ID string unique to this runtime for use by individual
//                  objects that are also tracked in the Lua state and have scripts
//                  associated with them.

string LuaMan::GetNewObjectID()
{
    // Generate the new ID
    char newID[64];
    sprintf(newID, "Obj%05i", m_NextObjectID);
    // Increment the ID so it will be diff for the next one (improve this primitive approach??)
    m_NextObjectID++;

    return string(newID);
}


//////////////////////////////////////////////////////////////////////////////////////////
// Method:          Update
//////////////////////////////////////////////////////////////////////////////////////////
// Description:     Updates the state of this LuaMan. Supposed to be done every frame
//                  before drawing.

void LuaMan::Update()
{
	lua_gc(m_pMasterState, LUA_GCSTEP, 1);
}

//////////////////////////////////////////////////////////////////////////////////////////
// Method:          FileOpen
//////////////////////////////////////////////////////////////////////////////////////////
// Description:     Opens file. You can open files only inside .rte folders of game directory.
//					you can open no more that MAX_OPEN_FILES file simultaneously.

int LuaMan::FileOpen(std::string filename, std::string mode)
{
	int fl = -1;

	// Find some suitable file
	for (int i = 0; i < MAX_OPEN_FILES; ++i)
		if (m_Files[i] == 0)
		{
			fl = i;
			break;
		}

	if (fl == -1)
	{
		g_ConsoleMan.PrintString("Error: Can't open file, no more slots.");
		return -1;
	}

	//Check for path back-traversing and .rte extension. Everything is allowed to read or write only inside rte's
    string dotString = "..";
	string rteString = ".rte";

	string fullPath = g_System.GetWorkingDirectory()+ "/" + filename;

	// Do not open paths with '..'
	if (fullPath.find(dotString) != string::npos)
		return -1;

	// Allow to edit files only inside .rte folders
	if (fullPath.find(rteString) == string::npos)
		return -1;

	// Open file and save handle
	FILE * f = fopen(fullPath.c_str(), mode.c_str());
	if (f)
	{
		m_Files[fl] = f;
		return fl;
	}

#ifdef _DEBUG
	g_ConsoleMan.PrintString("Error: Can't open file. " + fullPath);
#endif
	return -1;
}

//////////////////////////////////////////////////////////////////////////////////////////
// Method:          FileClose
//////////////////////////////////////////////////////////////////////////////////////////
// Description:     Closes a previously opened file.

void LuaMan::FileClose(int file)
{
	if (file > -1 && file < MAX_OPEN_FILES && m_Files[file])
	{
		fclose(m_Files[file]);
		m_Files[file] = 0;
	}
}


//////////////////////////////////////////////////////////////////////////////////////////
// Method:          FileCloseAll
//////////////////////////////////////////////////////////////////////////////////////////
// Description:     Closes all previously opened files.

void LuaMan::FileCloseAll()
{
	for (int file = 0 ; file < MAX_OPEN_FILES ; ++file)
		FileClose(file);
}


//////////////////////////////////////////////////////////////////////////////////////////
// Method:          FileReadLine
//////////////////////////////////////////////////////////////////////////////////////////
// Description:     Reads a line from file.
// Arguments:       File number.
// Return value:    Line from file, or empty string on error.

std::string LuaMan::FileReadLine(int file)
{
	if (file > -1 && file < MAX_OPEN_FILES && m_Files[file])
	{
		char buf[4096];
		fgets(buf, 4095, m_Files[file]);
		return (std::string(buf));
	}
	g_ConsoleMan.PrintString("Error: Tried to read a closed file, or read past EOF.");
	return "";
}

//////////////////////////////////////////////////////////////////////////////////////////
// Method:          FileWriteLine
//////////////////////////////////////////////////////////////////////////////////////////
// Description:     Writes a text line to file.
// Arguments:       File number.
// Return value:    None.

void LuaMan::FileWriteLine(int file, std::string line)
{
	if (file > -1 && file < MAX_OPEN_FILES && m_Files[file])
		fputs(line.c_str(), m_Files[file]);
	else
		g_ConsoleMan.PrintString("Error: Tried to write to a closed file.");
}

//////////////////////////////////////////////////////////////////////////////////////////
// Method:          FileEOF
//////////////////////////////////////////////////////////////////////////////////////////
// Description:     Returns true if end of file was reached
// Arguments:       File number.
// Return value:    Whether or not EOF was reached.

bool LuaMan::FileEOF(int file)
{
	if (file > -1 && file < MAX_OPEN_FILES && m_Files[file])
		if (!feof(m_Files[file]))
			return false;
	return true;
}

} // namespace RTE
